local success, err = pcall(function()
  assert(getgc, "executor missing required function getgc")
  assert(debug.info, "executor missing required function debug.info")
  assert(hookfunction, "executor missing required function hookfunction")
  assert(getconnections, "executor missing required function getconnections")
    
  for _,v in getgc() do
      if typeof(v) == "function" and string.find(debug.info(v, "s"), "AnalyticsPipelineController") then
          hookfunction(v, function() return task.wait(9e9) end)
      end
  end
  
  for _,v in getconnections(game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("AnalyticsPipeline"):WaitForChild("RemoteEvent").OnClientEvent) do
    hookfunction(v.Function, function() end)
  end
end)

if not success then
else
end

task.wait(1)

for _,v in getgc() do
    if typeof(v) == "thread" and string.find(debug.info(v, 1, "s") or "", "AnalyticsPipelineController") then
        task.cancel(v)
    end
end

pcall(function()
    for _,v in getgc() do
        if typeof(v) == "function" and string.find(debug.info(v, "s"), "AnalyticsPipelineController") then
            hookfunction(v, function() return task.wait(9e9) end)
            break
        end
    end
    
    local connections = getconnections(game:GetService("ReplicatedStorage").Remotes.AnalyticsPipeline.RemoteEvent.OnClientEvent)
    for _,v in connections do
        hookfunction(v.Function, function() end)
    end
end)

local Analytics = require(game:GetService("ReplicatedFirst"):WaitForChild("AnalyticsPipelineController"):WaitForChild("AnalyticsPipeline"))

local old; old = hookfunction(Analytics, function(...)
    return
end)

for i,v in getconnections(game:GetService("ReplicatedStorage").Remotes.AnalyticsPipeline.RemoteEvent.OnClientEvent) do
    hookfunction(v.Function, function() end)
end

task.wait(3)

local RunService = game:GetService("RunService")

task.wait(1)

local Library = loadstring(game:HttpGet('https://pastefy.app/GH6wtNbw/raw'))()
local SaveManager = loadstring(game:HttpGet('https://pastefy.app/TcRas1ug/raw'))()
local ThemeManager = loadstring(game:HttpGet('https://pastefy.app/phkvcGoK/raw'))()
local Window = Library:CreateWindow({
    Title = 'instance.elf',
    Center = true,
    AutoShow = true,
    TabPadding = 6,
    MenuFadeTime = 0.2,
    RedRightText = ' Rivals' 
})
local Tabs = {
    Legit = Window:AddTab("legit"),
    Rage = Window:AddTab("rage"),
    Visuals = Window:AddTab("visuals"),
    World = Window:AddTab("world"),
    Misc = Window:AddTab("misc"),
    ['UI Settings'] = Window:AddTab('settings'),
}
local LeftGroup = Tabs.Rage:AddLeftGroupbox("gun mods")

local toggleConnections = {}


local function toggleTableAttribute(attribute, value)
    for _, gcVal in pairs(getgc(true)) do
        if type(gcVal) == "table" and rawget(gcVal, attribute) then
            gcVal[attribute] = value
        end
    end
end


local muzzleFlashConnection = nil


local function removeMuzzleFlash()
    local viewModels = Workspace:FindFirstChild("ViewModels")
    if viewModels then
        local firstPerson = viewModels:FindFirstChild("FirstPerson")
        if firstPerson then
            for _, model in pairs(firstPerson:GetChildren()) do
                if model:IsA("Model") then
                    local itemVisual = model:FindFirstChild("ItemVisual")
                    if itemVisual then
                        local body = itemVisual:FindFirstChild("Body")
                        if body then
                            local bodyPrimary = body:FindFirstChild("BodyPrimary")
                            if bodyPrimary then
                                local muzzle = bodyPrimary:FindFirstChild("_muzzle")
                                if muzzle then
                                    local spotlight = muzzle:FindFirstChild("SpotLight")
                                    if spotlight then
                                        spotlight:Destroy()
                                    end
                                    for _, child in pairs(muzzle:GetChildren()) do
                                        if child:IsA("ParticleEmitter") and child.Name == "ParticleEmiter" then
                                            child:Destroy()
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end


LeftGroup:AddToggle("NoCooldown", {
    Text = "rapid fire",
    Default = false,
    Callback = function(val)
        if val then
            toggleTableAttribute("ShootCooldown", 0)
        end
    end
})


LeftGroup:AddToggle("NoSpread", {
    Text = "no spread",
    Default = false,
    Callback = function(val)
        if val then
            toggleTableAttribute("ShootSpread", 0)
        end
    end
})


LeftGroup:AddToggle("NoRecoil", {
    Text = "no recoil",
    Default = false,
    Callback = function(val)
        if val then
            toggleTableAttribute("ShootRecoil", 0)
        end
    end
})


LeftGroup:AddToggle("RapidAttack", {
    Text = "rapid attack",
    Default = false,
    Callback = function(val)
        if val then
            toggleTableAttribute("AttackCooldown", 0)
        end
    end
})


LeftGroup:AddToggle("RapidDeflect", {
    Text = "rapid deflect",
    Default = false,
    Callback = function(val)
        if val then
            toggleTableAttribute("DeflectCooldown", 0)
        end
    end
})


LeftGroup:AddToggle("RapidDash", {
    Text = "rapid dash",
    Default = false,
    Callback = function(val)
        if val then
            toggleTableAttribute("DashCooldown", 0)
        end
    end
})


LeftGroup:AddToggle("InfiniteDoubleJump", {
    Text = "infinite double jump",
    Default = false,
    Callback = function(val)
        if val then
            toggleTableAttribute("MaxDoubleJumps", 99999)
        end
    end
})


LeftGroup:AddToggle("NoMuzzleFlash", {
    Text = "no muzzle flash",
    Default = false,
    Callback = function(val)
        if val then
            
            removeMuzzleFlash()
            
            
            if muzzleFlashConnection then
                muzzleFlashConnection:Disconnect()
            end
            muzzleFlashConnection = RunService.RenderStepped:Connect(removeMuzzleFlash)
        else
            
            if muzzleFlashConnection then
                muzzleFlashConnection:Disconnect()
                muzzleFlashConnection = nil
            end
        end
    end
})

do
local RightGroup = Tabs.Legit:AddLeftGroupbox("silent")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Utility = require(ReplicatedStorage.Modules.Utility)
local LocalPlayer = Players.LocalPlayer
local OriginalRaycast = Utility.Raycast

local restrictedWeapons = {
    "Flamethrower",
    "Fists",
    "Battle Axe",
    "Chainsaw",
    "Katana",
    "Knife",
    "Riot Shield",
    "Scythe",
    "Maul",
    "Trowel",
    "Grenade",
    "Flashbang",
    "Jump Pad",
    "Molotov",
    "Satchel",
    "Smoke Grenade",
    "War Horn",
    "Medkit",
    "Subspace Tripmine",
    "Warpstone"
}

local antiKatanaEnabled = false

local katana_users = {}

local function setupKatanaDetection()
    local PlayerService = game:GetService("Players")
    local local_player = PlayerService.LocalPlayer
    
    if not local_player:FindFirstChild("PlayerScripts") then
        local_player.PlayerScriptsAdded:Wait()
    end
    
    task.spawn(function()
        local katana = nil
        local attempts = 0
        
        while attempts < 10 do
            pcall(function()
                local katanaModule = local_player.PlayerScripts.Modules.Items:FindFirstChild("Katana", true)
                if katanaModule then
                    katana = require(katanaModule)
                end
            end)
            
            if not katana then
                for _, module in pairs(local_player.PlayerScripts:GetDescendants()) do
                    if module.Name == "Katana" and module:IsA("ModuleScript") then
                        local success, katanaModule = pcall(require, module)
                        if success then
                            katana = katanaModule
                            break
                        end
                    end
                end
            end
            
            if katana and type(katana) == "table" and katana.StartAiming then
                break
            end
            
            attempts = attempts + 1
            task.wait(1)
        end
        
        if katana and type(katana) == "table" and katana.StartAiming then
            local old = katana.StartAiming
            
            katana.StartAiming = function(self, force)
                local fighter = self.ClientFighter
                local player = fighter and fighter.Player
                
                if player then
                    katana_users[player] = true
                    
                    local deflectDuration = self.Info.DeflectDuration or 0.6
                    
                    task.delay(deflectDuration, function()
                        katana_users[player] = nil
                    end)
                end
                
                return old(self, force)
            end
        end
    end)
end

setupKatanaDetection()

local function is_katana_deflecting(player)
    return katana_users[player] == true
end

local function getTargetEquippedWeapon(targetPlayer)
    local viewModels = Workspace:FindFirstChild("ViewModels")
    if not viewModels then return "None" end
    
    local playerName = targetPlayer.Name
    
    for _, child in ipairs(viewModels:GetChildren()) do
        local childName = child.Name
        local parts = {}
        for part in childName:gmatch("[^-]+") do
            table.insert(parts, part:match("^%s*(.-)%s*$"))
        end
        
        if #parts >= 2 and parts[1] == playerName then
            return parts[2]
        end
    end
    
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if firstPerson then
        for _, child in ipairs(firstPerson:GetChildren()) do
            local childName = child.Name
            local parts = {}
            for part in childName:gmatch("[^-]+") do
                table.insert(parts, part:match("^%s*(.-)%s*$"))
            end
            
            if #parts >= 2 and parts[1] == playerName then
                return parts[2]
            end
        end
    end
    
    return "None"
end

local function isWeaponRestricted(weaponName)
    if not weaponName then return false end
    for _, restrictedWeapon in ipairs(restrictedWeapons) do
        if weaponName == restrictedWeapon then
            return true
        end
    end
    return false
end

local function getCurrentWeapon()
    local viewModels = Workspace:FindFirstChild("ViewModels")
    if not viewModels then return nil end
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if not firstPerson then return nil end
    for _, child in ipairs(firstPerson:GetChildren()) do
        local childName = child.Name
        local parts = {}
        for part in childName:gmatch("[^-]+") do
            table.insert(parts, part:match("^%s*(.-)%s*$"))
        end
        if #parts >= 2 then
            return parts[2]
        end
    end
    return nil
end


local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 0.8
fovCircle.NumSides = 100
fovCircle.Filled = false
fovCircle.Transparency = 1
fovCircle.Visible = false
fovCircle.Radius = 100
fovCircle.Color = Color3.fromRGB(255, 255, 255)

local hitTracerEnabled = false
local hitTracerColor = Color3.fromRGB(255, 255, 255)
local hitTracerStyle = "Line"
local hitTracerGlow = 0
local hitTracerSize = 1
local hitTracerDuration = 3
local hitTracerFadeTime = 0.5

local bulletTracerEnabled = false
local bulletTracerColor = Color3.fromRGB(255, 255, 255)
local bulletTracerStyle = "Line"
local bulletTracerGlow = 0
local bulletTracerSize = 1
local bulletTracerDuration = 3
local bulletTracerFadeTime = 0.5

local bulletTracers = {}
local lastShotTime = 0
local shootCooldown = 0.1

local textureAssets = {
    ["Line"] = "",
    ["Beam"] = "rbxassetid://12781852245",
    ["Lightning"] = "rbxassetid://446111271",
    ["Heartrate"] = "rbxassetid://5830549480",
    ["Chain"] = "rbxassetid://9632168658",
    ["Glitch"] = "rbxassetid://8089467613",
    ["Swirl"] = "rbxassetid://5638168605",
    ["Neon"] = "rbxassetid://6361963422",
    ["Plasma"] = "rbxassetid://8993645509",
    ["Laser"] = "rbxassetid://14549123968",
}

local soundAssets = {
    ["Rust HS"] = "rbxassetid://5043539486",
    ["Neverlose"] = "rbxassetid://97643101798871",
    ["Minecraft Bow"] = "rbxassetid://3442683707",
    ["Minecraft Hit"] = "rbxassetid://8766809464",
    ["CSGO"] = "rbxassetid://5764885315",
}

local hitPartList = {
    "Head",
    "HumanoidRootPart",
    "Torso",
    "UpperTorso",
    "LowerTorso",
    "Left Arm",
    "LeftHand",
    "LeftLowerArm",
    "LeftUpperArm",
    "Right Arm",
    "RightHand",
    "RightLowerArm",
    "RightUpperArm",
    "Left Leg",
    "LeftFoot",
    "LeftLowerLeg",
    "LeftUpperLeg",
    "Right Leg",
    "RightFoot",
    "RightLowerLeg",
    "RightUpperLeg",
    "Neck",
    "Back",
    "Front",
    "Closest",
    "Random"
}

local hitChance = 100
local currentTarget = nil
local targetLastHealth = {}
local hitSoundEnabled = false
local hitSoundStyle = "Rust HS"
local hitSoundVolume = 0.5
local hitSoundPitch = 1.0
local lastHitTime = 0

local silentAimEnabled = false
local hitPart = "Head"
local FOVRadius = 100
local autoShootEnabled = false



local function getMuzzlePosition()
    local viewModels = Workspace:FindFirstChild("ViewModels")
    if not viewModels then return nil end
    
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if not firstPerson then return nil end
    
    local playerName = LocalPlayer.Name
    
    for _, model in pairs(firstPerson:GetChildren()) do
        if model:IsA("Model") and model.Name:find("^" .. playerName) then
            local itemVisual = model:FindFirstChild("ItemVisual")
            if itemVisual then
                local body = itemVisual:FindFirstChild("Body")
                if body then
                    local bodyPrimary = body:FindFirstChild("BodyPrimary")
                    if bodyPrimary then
                        local muzzle = bodyPrimary:FindFirstChild("_muzzle")
                        if muzzle and muzzle:IsA("Attachment") then
                            return muzzle.WorldPosition
                        end
                    end
                end
            end
        end
    end
    
    return nil
end

local function createBulletTracer(startPos, endPos, isHitTracer)
    if isHitTracer then
        local muzzlePos = getMuzzlePosition()
        if muzzlePos then
            startPos = muzzlePos
        end
    end
    
    local currentStyle = isHitTracer and hitTracerStyle or bulletTracerStyle
    local currentGlow = isHitTracer and hitTracerGlow or bulletTracerGlow
    local currentSize = isHitTracer and hitTracerSize or bulletTracerSize
    local currentDuration = isHitTracer and hitTracerDuration or bulletTracerDuration
    local currentFadeTime = isHitTracer and hitTracerFadeTime or bulletTracerFadeTime
    local currentColor = isHitTracer and hitTracerColor or bulletTracerColor
    
    if isHitTracer and currentStyle == "Line" then
        local direction = (endPos - startPos)
        local distance = direction.Magnitude
        local segmentLength = 5
        local numSegments = math.ceil(distance / segmentLength)
        
        local segments = {}
        
        for i = 1, numSegments do
            local segStart = startPos + (direction.Unit * ((i - 1) * segmentLength))
            local segEnd = startPos + (direction.Unit * math.min(i * segmentLength, distance))
            
            local line = Drawing.new("Line")
            line.Thickness = 2 * currentSize
            line.Color = currentColor
            line.Transparency = 1
            line.Visible = false
            
            table.insert(segments, {
                Line = line,
                StartPos = segStart,
                EndPos = segEnd
            })
        end
        
        local tracer = {
            Segments = segments,
            Lifetime = currentDuration,
            CreatedTime = tick(),
            IsHitTracer = true,
            Is2D = true,
            FadeStartTime = tick() + currentDuration - currentFadeTime,
            StartPos = startPos,
            EndPos = endPos
        }
        
        table.insert(bulletTracers, tracer)
        return tracer
    else
        
        local attachment0 = Instance.new("Attachment")
        attachment0.Position = Vector3.new(0, 0, 0)
        attachment0.Parent = workspace.Terrain
        
        local attachment1 = Instance.new("Attachment")
        attachment1.Position = Vector3.new(0, 0, 0)
        attachment1.Parent = workspace.Terrain
        
        local beam = Instance.new("Beam")
        beam.Attachment0 = attachment0
        beam.Attachment1 = attachment1
        
        beam.Color = ColorSequence.new(currentColor)
        
        local baseWidth = 0.05
        
        if currentStyle == "Line" then
            baseWidth = 0.05
        elseif currentStyle == "Laser" then
            baseWidth = 0.02
        else
            baseWidth = 0.15
        end
        
        beam.Width0 = baseWidth * currentSize
        beam.Width1 = baseWidth * currentSize
        beam.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(0.8, 0.1),
            NumberSequenceKeypoint.new(1, 0.5)
        })
        beam.FaceCamera = false
        beam.LightEmission = currentGlow
        beam.LightInfluence = 1 - currentGlow
        
        local glow = nil
        if currentGlow > 0.3 then
            glow = Instance.new("PointLight")
            glow.Brightness = currentGlow * 2
            glow.Range = 10 * currentSize
            glow.Color = currentColor
            glow.Parent = attachment1
        end
        
        if currentStyle == "Line" then
            beam.Texture = ""
            beam.TextureLength = 1
            beam.TextureSpeed = 0
        elseif textureAssets[currentStyle] then
            beam.Texture = textureAssets[currentStyle]
            beam.TextureLength = 4
            beam.TextureSpeed = 1
        else
            beam.Texture = ""
        end
        
        beam.Parent = workspace.Terrain
        
        attachment0.WorldPosition = startPos
        attachment1.WorldPosition = endPos
        
        local tracer = {
            Line = beam,
            Attachment0 = attachment0,
            Attachment1 = attachment1,
            Light = glow,
            Lifetime = currentDuration,
            CreatedTime = tick(),
            IsHitTracer = isHitTracer,
            Is2D = false,
            FadeStartTime = tick() + currentDuration - currentFadeTime
        }
        
        table.insert(bulletTracers, tracer)
        
        return tracer
    end
end


local function updateTracerGlow()
    for _, tracer in ipairs(bulletTracers) do
        if tracer and not tracer.Is2D and tracer.Line then
            local currentTime = tick()
            local age = currentTime - tracer.CreatedTime
            if age >= tracer.FadeStartTime then
                local fadeProgress = (age - tracer.FadeStartTime) / (tracer.IsHitTracer and hitTracerFadeTime or bulletTracerFadeTime)
                local newTransparency = math.clamp(fadeProgress, 0, 1)
                tracer.Line.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, newTransparency),
                    NumberSequenceKeypoint.new(0.8, newTransparency + 0.1),
                    NumberSequenceKeypoint.new(1, 1)
                })
                if tracer.Line.LightEmission > 0 then
                    tracer.Line.LightEmission = (tracer.IsHitTracer and hitTracerGlow or bulletTracerGlow) * (1 - fadeProgress)
                end
                if tracer.Light then
                    tracer.Light.Brightness = tracer.Light.Brightness * (1 - fadeProgress)
                end
            end
        end
    end
end

local function setupShootDetection()
    RunService.RenderStepped:Connect(function()
        if not bulletTracerEnabled then return end
        
        local currentTime = tick()
        if currentTime - lastShotTime < shootCooldown then return end
        
        local myChar = LocalPlayer.Character
        if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return end
        
        local currentWeapon = getCurrentWeapon()
        if not currentWeapon then return end
        
        local isRestricted = isWeaponRestricted(currentWeapon)
        local isMelee = false
        
        local meleeWeapons = {
            "Fists",
            "Battle Axe",
            "Chainsaw",
            "Katana",
            "Knife",
            "Riot Shield",
            "Scythe",
            "Maul",
            "Trowel"
        }
        
        for _, weapon in ipairs(meleeWeapons) do
            if currentWeapon == weapon then
                isMelee = true
                break
            end
        end
        
        if isRestricted or isMelee then return end
        
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            lastShotTime = currentTime
            
            local muzzlePos
            local gunFound = false
            local viewModels = Workspace:FindFirstChild("ViewModels")
            
            if viewModels then
                local firstPerson = viewModels:FindFirstChild("FirstPerson")
                if firstPerson then
                    for _, model in pairs(firstPerson:GetChildren()) do
                        if model:IsA("Model") then
                            local muzzle = model:FindFirstChild("Muzzle") or 
                                          model:FindFirstChild("MuzzleFlash") or
                                          model:FindFirstChild("Barrel") or
                                          model:FindFirstChild("GunTip") or
                                          model:FindFirstChild("Flash") or
                                          model:FindFirstChild("Fire") or
                                          model:FindFirstChild("Tip")
                            
                            if muzzle then
                                muzzlePos = muzzle.Position
                                gunFound = true
                                break
                            else
                                for _, part in pairs(model:GetChildren()) do
                                    if part:IsA("BasePart") then
                                        local partName = part.Name:lower()
                                        if partName:find("tip") or partName:find("barrel") or partName:find("muzzle") or partName:find("flash") or partName:find("fire") or partName:find("gun") then
                                            muzzlePos = part.Position
                                            gunFound = true
                                            break
                                        end
                                    end
                                end
                                
                                if not gunFound then
                                    local primaryPart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                                    if primaryPart then
                                        muzzlePos = primaryPart.Position
                                        gunFound = true
                                    end
                                end
                            end
                            
                            if gunFound then break end
                        end
                    end
                end
            end
            
            if not gunFound then
                muzzlePos = Camera.CFrame.Position + (Camera.CFrame.LookVector * 4)
            end
            
            local endPos = Camera.CFrame.Position + (Camera.CFrame.LookVector * 1000)
            
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {myChar}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            
            local result = workspace:Raycast(muzzlePos, (endPos - muzzlePos).Unit * 1000, params)
            if result then
                endPos = result.Position
            end
            
            createBulletTracer(muzzlePos, endPos, false)
        end
    end)
end

local function playHitSound()
    local soundId = soundAssets[hitSoundStyle]
    if not soundId then return end
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = hitSoundVolume
    sound.Pitch = hitSoundPitch
    sound.Parent = workspace
    local camera = workspace.CurrentCamera
    if camera then
        local soundAttachment = Instance.new("Attachment")
        soundAttachment.Parent = camera
        sound.Parent = soundAttachment
    end
    sound:Play()
    game:GetService("Debris"):AddItem(sound, 5)
    if sound.Parent then
        game:GetService("Debris"):AddItem(sound.Parent, 5)
    end
end

local function checkForHit()
    if not currentTarget then return end
    local character = currentTarget
    if not character or not character.Parent then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local targetPlayer = Players:GetPlayerFromCharacter(character)
    if not targetPlayer then return end
    local lastHealth = targetLastHealth[targetPlayer] or humanoid.Health
    if humanoid.Health < lastHealth then
        local myChar = LocalPlayer.Character
        if myChar and myChar:FindFirstChild("HumanoidRootPart") then
            local targetRoot = character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                local distance = (myChar.HumanoidRootPart.Position - targetRoot.Position).Magnitude
                if distance <= 1500 then
                    local myPos = myChar.HumanoidRootPart.Position
                    local targetPos = targetRoot.Position
                    local direction = (targetPos - myPos).Unit
                    local params = RaycastParams.new()
                    params.FilterDescendantsInstances = {myChar, character}
                    params.FilterType = Enum.RaycastFilterType.Exclude
                    local result = workspace:Raycast(myPos, direction * distance, params)
                    local isVisible = true
                    if result then
                        local hitPart = result.Instance
                        local hitParent = hitPart.Parent
                        if hitParent ~= character and hitParent.Parent ~= character then
                            isVisible = false
                        end
                    end
                    if isVisible and tick() - lastHitTime > 0.05 then
                        lastHitTime = tick()
                        if hitTracerEnabled then
                            local tracerStart = Camera.CFrame.Position + (Camera.CFrame.LookVector * 2)
                            createBulletTracer(tracerStart, targetRoot.Position, true)
                        end
                        if hitSoundEnabled then
                            task.spawn(function()
                                playHitSound()
                            end)
                        end
                    end
                end
            end
        end
    end
    targetLastHealth[targetPlayer] = humanoid.Health
end

RunService.RenderStepped:Connect(function()
    if fovCircle.Visible then
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        fovCircle.Position = center
    end
    
    updateTracerGlow()
    
    for _, tracer in ipairs(bulletTracers) do
        if tracer and tracer.Is2D and tracer.Segments then
            local currentTime = tick()
            local age = currentTime - tracer.CreatedTime
            local myChar = LocalPlayer.Character
            local myPos = myChar and myChar:FindFirstChild("HumanoidRootPart") and myChar.HumanoidRootPart.Position
            
            for _, segment in ipairs(tracer.Segments) do
                local shouldShow = false
                local fromPos, toPos
                
                pcall(function()
                    local segmentStart, onScreenStart = Camera:WorldToViewportPoint(segment.StartPos)
                    local segmentEnd, onScreenEnd = Camera:WorldToViewportPoint(segment.EndPos)
                    
                    
                    if myPos then
                        local distToStart = (segment.StartPos - myPos).Magnitude
                        local distToEnd = (segment.EndPos - myPos).Magnitude
                        if distToStart < 2 or distToEnd < 2 then
                            return
                        end
                    end
                    
                    
                    if segmentStart.Z <= 0 or segmentEnd.Z <= 0 then
                        return
                    end
                    
                    
                    if not (segmentStart.X and segmentStart.Y and segmentEnd.X and segmentEnd.Y) then
                        return
                    end
                    
                    
                    if math.abs(segmentStart.X) > 20000 or math.abs(segmentStart.Y) > 20000 or 
                       math.abs(segmentEnd.X) > 20000 or math.abs(segmentEnd.Y) > 20000 then
                        return
                    end
                    
                    fromPos = Vector2.new(segmentStart.X, segmentStart.Y)
                    toPos = Vector2.new(segmentEnd.X, segmentEnd.Y)
                    
                    local lineLength = (toPos - fromPos).Magnitude
                    
                    
                    if lineLength < 3000 and lineLength > 0.1 then
                        shouldShow = true
                    end
                end)
                
                if shouldShow and fromPos and toPos then
                    segment.Line.From = fromPos
                    segment.Line.To = toPos
                    segment.Line.Visible = true
                    
                    if age >= (tracer.Lifetime - hitTracerFadeTime) then
                        local fadeProgress = (age - (tracer.Lifetime - hitTracerFadeTime)) / hitTracerFadeTime
                        segment.Line.Transparency = 1 - math.clamp(fadeProgress, 0, 1)
                    else
                        segment.Line.Transparency = 1
                    end
                else
                    segment.Line.Visible = false
                end
            end
        end
    end
    
    for i = #bulletTracers, 1, -1 do
        local tracer = bulletTracers[i]
        if tracer and (tick() - tracer.CreatedTime >= tracer.Lifetime) then
            if tracer.Is2D and tracer.Segments then
                for _, segment in ipairs(tracer.Segments) do
                    if segment.Line then
                        segment.Line:Remove()
                    end
                end
            elseif tracer.Line then
                tracer.Line:Destroy()
            end
            
            if tracer.Attachment0 then
                tracer.Attachment0:Destroy()
            end
            if tracer.Attachment1 then
                tracer.Attachment1:Destroy()
            end
            if tracer.Light then
                tracer.Light:Destroy()
            end
            table.remove(bulletTracers, i)
        end
    end
end)

RunService.RenderStepped:Connect(function()
    checkForHit()
end)



local function getHitPartFromName(target, partName)
    if partName == "Head" then
        return target:FindFirstChild("Head")
    elseif partName == "HumanoidRootPart" then
        return target:FindFirstChild("HumanoidRootPart")
    elseif partName == "Torso" then
        return target:FindFirstChild("Torso") or target:FindFirstChild("UpperTorso")
    elseif partName == "UpperTorso" then
        return target:FindFirstChild("UpperTorso")
    elseif partName == "LowerTorso" then
        return target:FindFirstChild("LowerTorso")
    elseif partName == "Left Arm" then
        return target:FindFirstChild("Left Arm") or target:FindFirstChild("LeftUpperArm")
    elseif partName == "LeftHand" then
        return target:FindFirstChild("LeftHand") or target:FindFirstChild("Left Arm")
    elseif partName == "LeftLowerArm" then
        return target:FindFirstChild("LeftLowerArm")
    elseif partName == "LeftUpperArm" then
        return target:FindFirstChild("LeftUpperArm")
    elseif partName == "Right Arm" then
        return target:FindFirstChild("Right Arm") or target:FindFirstChild("RightUpperArm")
    elseif partName == "RightHand" then
        return target:FindFirstChild("RightHand") or target:FindFirstChild("Right Arm")
    elseif partName == "RightLowerArm" then
        return target:FindFirstChild("RightLowerArm")
    elseif partName == "RightUpperArm" then
        return target:FindFirstChild("RightUpperArm")
    elseif partName == "Left Leg" then
        return target:FindFirstChild("Left Leg") or target:FindFirstChild("LeftUpperLeg")
    elseif partName == "LeftFoot" then
        return target:FindFirstChild("LeftFoot") or target:FindFirstChild("Left Leg")
    elseif partName == "LeftLowerLeg" then
        return target:FindFirstChild("LeftLowerLeg")
    elseif partName == "LeftUpperLeg" then
        return target:FindFirstChild("LeftUpperLeg")
    elseif partName == "Right Leg" then
        return target:FindFirstChild("Right Leg") or target:FindFirstChild("RightUpperLeg")
    elseif partName == "RightFoot" then
        return target:FindFirstChild("RightFoot") or target:FindFirstChild("Right Leg")
    elseif partName == "RightLowerLeg" then
        return target:FindFirstChild("RightLowerLeg")
    elseif partName == "RightUpperLeg" then
        return target:FindFirstChild("RightUpperLeg")
    elseif partName == "Neck" then
        return target:FindFirstChild("Neck")
    elseif partName == "Back" then
        return target:FindFirstChild("Back") or target:FindFirstChild("HumanoidRootPart")
    elseif partName == "Front" then
        return target:FindFirstChild("Front") or target:FindFirstChild("HumanoidRootPart")
    elseif partName == "Closest" then
        local myChar = LocalPlayer.Character
        if not myChar then return target:FindFirstChild("HumanoidRootPart") end
        local cameraPos = Camera.CFrame.Position
        local cameraLook = Camera.CFrame.LookVector
        local closestPart = nil
        local closestDist = math.huge
        for _, part in pairs(target:GetChildren()) do
            if part:IsA("BasePart") then
                local toPart = (part.Position - cameraPos).Unit
                local dot = cameraLook:Dot(toPart)
                local dist = 1 - dot
                if dist < closestDist then
                    closestDist = dist
                    closestPart = part
                end
            end
        end
        return closestPart or target:FindFirstChild("HumanoidRootPart")
    elseif partName == "Random" then
        local hitboxes = {}
        for _, part in pairs(target:GetChildren()) do
            if part:IsA("BasePart") then
                table.insert(hitboxes, part)
            end
        end
        if #hitboxes > 0 then
            return hitboxes[math.random(1, #hitboxes)]
        end
    end
    return target:FindFirstChild("HumanoidRootPart")
end

local function shouldHitTarget()
    if hitChance >= 100 then return true end
    if hitChance <= 0 then return false end
    local randomChance = math.random(1, 100)
    return randomChance <= hitChance
end

local function getRandomPointAwayFromPlayer(playerChar)
    local root = playerChar:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    
    local pos = root.Position
    local randomDistance = math.random(20, 50)
    local randomAngle = math.random() * math.pi * 2
    
    local offsetX = math.cos(randomAngle) * randomDistance
    local offsetZ = math.sin(randomAngle) * randomDistance
    local offsetY = math.random(-10, 20)
    
    return Vector3.new(
        pos.X + offsetX,
        pos.Y + offsetY,
        pos.Z + offsetZ
    )
end

local function getClosestPlayerInFOV(radius)
    local closest = nil
    local closestDist = math.huge
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local maxDist = fovCircle.Radius
    
    for _, player in Players:GetPlayers() do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local hum = character:FindFirstChildOfClass("Humanoid")
            if hum and hum.Health > 0 then
                if character:FindFirstChildOfClass("ForceField") then
                    continue
                end
                local root = character:FindFirstChild("HumanoidRootPart")
                if root then
                    local pos, onScreen = Camera:WorldToViewportPoint(root.Position)
                    if onScreen then
                        local screenPos = Vector2.new(pos.X, pos.Y)
                        local dist = (screenPos - screenCenter).Magnitude
                        
                        if dist <= maxDist and dist < closestDist then
                            closest = character
                            closestDist = dist
                        end
                    end
                end
            end
        end
    end
    
    currentTarget = closest
    return closest
end

local function shouldUseSilentAim()
    if not silentAimEnabled then
        return false
    end
    local currentWeapon = getCurrentWeapon()
    if currentWeapon and isWeaponRestricted(currentWeapon) then
        return false
    end
    return true
end

local function autoShoot()
    if not autoShootEnabled then return end
    local currentWeapon = getCurrentWeapon()
    if currentWeapon and isWeaponRestricted(currentWeapon) then
        return
    end
    local closestTarget = getClosestPlayerInFOV(FOVRadius)
    if not closestTarget then return end
    local targetPlayer = Players:GetPlayerFromCharacter(closestTarget)
    
    if antiKatanaEnabled and targetPlayer and is_katana_deflecting(targetPlayer) then
        return
    end
    
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return end
    local targetRoot = closestTarget:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    mouse1press()
    task.wait(0.001)
    mouse1release()
end

local function silentAimRaycast(...)
    if not shouldUseSilentAim() then
        return OriginalRaycast(...)
    end
    if not shouldHitTarget() then
        return OriginalRaycast(...)
    end
    local args = {...}
    local closest = getClosestPlayerInFOV(FOVRadius)
    if closest then
        local targetPlayer = Players:GetPlayerFromCharacter(closest)
        
        if antiKatanaEnabled and targetPlayer and is_katana_deflecting(targetPlayer) then
            local randomPoint = getRandomPointAwayFromPlayer(closest)
            if randomPoint then
                args[3] = randomPoint
                return OriginalRaycast(table.unpack(args))
            else
                return OriginalRaycast(...)
            end
        end
        
        local targetHitPart = getHitPartFromName(closest, hitPart)
        if targetHitPart then
            args[3] = targetHitPart.Position
        end
    end
    return OriginalRaycast(table.unpack(args))
end

RunService.Heartbeat:Connect(function()
    autoShoot()
end)

RightGroup:AddToggle("SilentAim", {
    Text = "enable",
    Default = false,
    Callback = function(val)
        silentAimEnabled = val
        if val then
            Utility.Raycast = silentAimRaycast
        else
            Utility.Raycast = OriginalRaycast
            currentTarget = nil
        end
    end
}):AddKeyPicker("SilentAimKey", {
    Text = "Silent Aim",
    Default = "None",
    Mode = "Toggle",
    Callback = function(state)
        silentAimEnabled = state
        if state then
            Utility.Raycast = silentAimRaycast
        else
            Utility.Raycast = OriginalRaycast
            currentTarget = nil
        end
    end
})

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")

    local LocalPlayer = Players.LocalPlayer
    local Camera = workspace.CurrentCamera

    local selectedTarget = nil
    local backshootEnabled = false
    local backshootConnection = nil
    local originalCFrame = nil

    local function getClosestPlayer()
        local closest = nil
        local closestDistance = math.huge
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        for _, player in Players:GetPlayers() do
            if player ~= LocalPlayer and player.Character then
                local character = player.Character
                local root = character:FindFirstChild("HumanoidRootPart")
                
                if root then
                    local position, onScreen = Camera:WorldToViewportPoint(root.Position)
                    if onScreen then
                        local screenPos = Vector2.new(position.X, position.Y)
                        local distance = (screenCenter - screenPos).Magnitude
                        
                        if distance < closestDistance then
                            closest = character
                            closestDistance = distance
                        end
                    end
                end
            end
        end
        return closest
    end

    local function startBackshoot()
        if backshootConnection then backshootConnection:Disconnect() end
        
        backshootConnection = RunService.Heartbeat:Connect(function() 
            local myChar = LocalPlayer.Character
            if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return end
            
            if not selectedTarget then return end
            
            local targetRoot = selectedTarget:FindFirstChild("HumanoidRootPart")
            if not targetRoot then return end
            
            local targetLookVector = targetRoot.CFrame.LookVector
            
            local behindOffset = -targetLookVector * 5
            local newPosition = targetRoot.Position + behindOffset
            
            myChar.HumanoidRootPart.CFrame = CFrame.new(newPosition, targetRoot.Position)
        end)
    end

    local function stopBackshoot()
        if backshootConnection then
            backshootConnection:Disconnect()
            backshootConnection = nil
        end
    end

    RightGroup:AddToggle("BackshootToggle", {
        Text = "backshoot",
        Default = false,
        Callback = function(val)
            backshootEnabled = val
            if val and selectedTarget then
                startBackshoot()
            else
                stopBackshoot()
                if selectedTarget and originalCFrame then
                    local myChar = LocalPlayer.Character
                    if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                        myChar.HumanoidRootPart.CFrame = originalCFrame
                    end
                end
            end
        end
    }):AddKeyPicker("SelectTargetKey", {
        Text = "Backshoot",
        Default = "C",
        Mode = "Toggle",
        Callback = function(state)
            if state then
                local myChar = LocalPlayer.Character
                if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return end
                
                if selectedTarget then
                    if originalCFrame then
                        myChar.HumanoidRootPart.CFrame = originalCFrame
                    end
                    selectedTarget = nil
                    stopBackshoot()
                else
                    selectedTarget = getClosestPlayer()
                    if selectedTarget then
                        originalCFrame = myChar.HumanoidRootPart.CFrame
                        if backshootEnabled then
                            startBackshoot()
                        end
                    end
                end
            end
        end
    })

    spawn(function()
        while true do
            task.wait(0.1)
            if selectedTarget then
                local hum = selectedTarget:FindFirstChild("Humanoid")
                if not hum or hum.Health <= 0 then
                    local myChar = LocalPlayer.Character
                    if myChar and myChar:FindFirstChild("HumanoidRootPart") and originalCFrame then
                        myChar.HumanoidRootPart.CFrame = originalCFrame
                    end
                    selectedTarget = nil
                    stopBackshoot()
                end
            end
        end
    end)

    LocalPlayer.CharacterRemoving:Connect(function()
        stopBackshoot()
        selectedTarget = nil
        originalCFrame = nil
    end)

    Players.PlayerRemoving:Connect(function(player)
        if selectedTarget and player.Character == selectedTarget then
            local myChar = LocalPlayer.Character
            if myChar and myChar:FindFirstChild("HumanoidRootPart") and originalCFrame then
                myChar.HumanoidRootPart.CFrame = originalCFrame
            end
            selectedTarget = nil
            stopBackshoot()
        end
    end)

RightGroup:AddToggle("AntiKatana", {
    Text = "anti katana",
    Default = false,
    Tooltip = "Avoid shooting while players deflect with Katana",
    Callback = function(val)
        antiKatanaEnabled = val
    end
}):AddKeyPicker("AntiKatanaKey", {
    Text = "Anti Katana",
    Default = "None",
    Mode = "Toggle",
    Callback = function(state)
        antiKatanaEnabled = state
    end
})

RightGroup:AddToggle("AutoShoot", {
    Text = "auto shoot",
    Default = false,
    Callback = function(val)
        autoShootEnabled = val
    end
})

RightGroup:AddSlider("HitChance", {
    Text = "hit chance",
    Default = 100,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Compact = true,
    Callback = function(val)
        hitChance = val
    end
})

RightGroup:AddDropdown("HitPartDropdown", {
    Text = "hit part",
    Default = "Head",
    Values = hitPartList,
    Callback = function(val)
        hitPart = val
    end
})

RightGroup:AddToggle("ShowFOV", {
    Text = "show fov",
    Default = false,
    Callback = function(val)
        fovCircle.Visible = val
    end
}):AddColorPicker("FOVColorPicker", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "FOV Color",
    Callback = function(val)
        fovCircle.Color = val
    end
})

RightGroup:AddSlider("FOVRadius", {
    Text = "fov radius",
    Default = 100,
    Min = 10,
    Max = 750,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        FOVRadius = val
        fovCircle.Radius = val
    end
})

local aimbotGroup = Tabs.Legit:AddRightGroupbox("aimbot")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local player = Players.LocalPlayer

repeat task.wait(0.1) until game:IsLoaded()
repeat task.wait(0.1) until player.Parent
repeat task.wait(0.1) until player:FindFirstChild("PlayerScripts")
repeat task.wait(0.1) until UserInputService
repeat task.wait(0.1) until RunService
task.wait(0.8)
player:WaitForChild("PlayerScripts", 10)

local camController
pcall(function()
    local controllers = player.PlayerScripts:WaitForChild("Controllers", 10)
    local camMod = controllers:FindFirstChild("CameraController")
    if camMod and camMod:IsA("ModuleScript") then
        camController = require(camMod)
    end
end)

local aimKey = Enum.KeyCode.X
local targetPart = "Head"
local fovRadius = 500
local smoothness = 0.5
local aimbotEnabled = false
local showFov = false
local lockedTarget = nil

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 0.8
fovCircle.NumSides = 100
fovCircle.Filled = false
fovCircle.Transparency = 1
fovCircle.Visible = false
fovCircle.Radius = fovRadius
fovCircle.Color = Color3.fromRGB(255, 255, 255)

RunService.RenderStepped:Connect(function()
    pcall(function()
        if fovCircle.Visible then
            local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            fovCircle.Position = center
        end
    end)
end)

local function getClosestToCursor()
    local best, bestDist = nil, fovRadius
    local mouse = player:GetMouse()
    if not mouse then return nil end
    local mousePos = Vector2.new(mouse.X, mouse.Y)
    
    for _, p in Players:GetPlayers() do
        if p == player or not p.Character then continue end
        local part = p.Character:FindFirstChild(targetPart)
        if not part or not part:IsDescendantOf(workspace) then continue end
        
        local screen, onScreen = Camera:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local dist = (Vector2.new(screen.X, screen.Y) - mousePos).Magnitude
        if dist < bestDist then
            bestDist = dist
            best = part
        end
    end
    return best
end

local aimbotConnection
local function updateAimbot()
    if aimbotConnection then aimbotConnection:Disconnect() end
    
    if not aimbotEnabled then 
        lockedTarget = nil
        fovCircle.Visible = false
        return 
    end
    
    if showFov then
        fovCircle.Visible = true
        fovCircle.Radius = fovRadius
    end
    
    aimbotConnection = RunService.RenderStepped:Connect(function(dt)
        if not aimbotEnabled then 
            lockedTarget = nil
            return 
        end
        
        if not UserInputService:IsKeyDown(aimKey) then
            lockedTarget = nil
            return
        end
        
        if not lockedTarget then
            lockedTarget = getClosestToCursor()
            if not lockedTarget then return end
        end
        
        if not lockedTarget.Parent or not lockedTarget:IsDescendantOf(workspace) then
            lockedTarget = nil
            return
        end
        
        local myChar = player.Character
        if not myChar then return end
        
        local myHead = myChar:FindFirstChild("Head")
        if not myHead then 
            lockedTarget = nil
            return 
        end
        
        if not camController then return end
        
        local targetPos = lockedTarget.Position
        local myHeadPos = myHead.Position
        local lookAtCF = CFrame.lookAt(myHeadPos, targetPos)
        local currentCF = Camera.CFrame
        
        local invertedSmoothness = 1 - smoothness
        local smoothCF = currentCF:Lerp(lookAtCF, invertedSmoothness)
        
        if camController.MimicRotation then
            pcall(function()
                camController:MimicRotation(smoothCF)
            end)
        end
    end)
end

aimbotGroup:AddToggle("AimbotToggle", {
    Text = "enable",
    Default = false,
    Callback = function(val)
        aimbotEnabled = val
        updateAimbot()
    end
}):AddKeyPicker("AimbotKey", {
    Text = "Aimbot",
    Default = "X",
    Mode = "Hold",
    Callback = function(state)
        aimbotEnabled = state
        updateAimbot()
    end
})

aimbotGroup:AddSlider("AimbotSmoothness", {
    Text = "smoothness",
    Default = 0.5,
    Min = 0,
    Max = 0.99,
    Rounding = 2,
    Compact = true,
    Callback = function(val)
        smoothness = val
    end
})

aimbotGroup:AddDropdown("AimbotHitPart", {
    Text = "hit part",
    Default = "Head",
    Values = {"Head", "HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso"},
    Callback = function(val)
        targetPart = val
    end
})

aimbotGroup:AddSlider("AimbotFOV", {
    Text = "fov radius",
    Default = 500,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Compact = true,
    Callback = function(val)
        fovRadius = val
        if fovCircle then
            fovCircle.Radius = val
        end
    end
})

aimbotGroup:AddToggle("ShowAimbotFOV", {
    Text = "show fov",
    Default = false,
    Callback = function(val)
        showFov = val
        fovCircle.Visible = val and aimbotEnabled
    end
}):AddColorPicker("AimbotFOVColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "FOV Color",
    Callback = function(val) 
        fovCircle.Color = val 
    end
})

updateAimbot()

local HitTracerGroup = Tabs.World:AddRightGroupbox("hit tracers")

HitTracerGroup:AddToggle("HitTracers", {
    Text = "enable",
    Default = false,
    Callback = function(val)
        hitTracerEnabled = val
    end
}):AddColorPicker("HitTracerColorPicker", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Hit Tracer Color",
    Callback = function(val)
        hitTracerColor = val
        for _, tracer in ipairs(bulletTracers) do
            if tracer.IsHitTracer and tracer.Is2D and tracer.Segments then
                for _, segment in ipairs(tracer.Segments) do
                    if segment.Line then
                        segment.Line.Color = val
                    end
                end
            elseif tracer.IsHitTracer and tracer.Line then
                tracer.Line.Color = ColorSequence.new(val)
            end
            if tracer.IsHitTracer and tracer.Light then
                tracer.Light.Color = val
            end
        end
    end
})


HitTracerGroup:AddDropdown("HitTracerStyleDropdown", {
    Text = "style",
    Default = "Line",
    Values = {"Line", "Beam", "Lightning", "Heartrate", "Chain", "Glitch", "Swirl", "Neon", "Plasma", "Laser"},
    Callback = function(val)
        hitTracerStyle = val
        for _, tracer in ipairs(bulletTracers) do
            if tracer.IsHitTracer and tracer.Line then
                if val == "Line" then
                    tracer.Line.Texture = ""
                    tracer.Line.TextureLength = 1
                    tracer.Line.TextureSpeed = 0
                elseif textureAssets[val] then
                    tracer.Line.Texture = textureAssets[val]
                    tracer.Line.TextureLength = 4
                    tracer.Line.TextureSpeed = 1
                else
                    tracer.Line.Texture = ""
                end
            end
        end
    end
})

HitTracerGroup:AddSlider("HitTracerGlow", {
    Text = "glow intensity",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(val)
        hitTracerGlow = val
        for _, tracer in ipairs(bulletTracers) do
            if tracer.IsHitTracer and tracer.Line then
                tracer.Line.LightEmission = val
            end
            if tracer.IsHitTracer and tracer.Light then
                tracer.Light.Brightness = val * 2
                tracer.Light.Enabled = val > 0.3
            end
        end
    end
})

HitTracerGroup:AddSlider("HitTracerSize", {
    Text = "size",
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        hitTracerSize = val
        for _, tracer in ipairs(bulletTracers) do
            if tracer.IsHitTracer and tracer.Is2D and tracer.Segments then
                for _, segment in ipairs(tracer.Segments) do
                    if segment.Line then
                        segment.Line.Thickness = 2 * val
                    end
                end
            elseif tracer.IsHitTracer and tracer.Line then
                local baseWidth = 0.05
                if hitTracerStyle == "Line" then
                    baseWidth = 0.05
                elseif hitTracerStyle == "Laser" then
                    baseWidth = 0.02
                else
                    baseWidth = 0.15
                end
                tracer.Line.Width0 = baseWidth * val
                tracer.Line.Width1 = baseWidth * val
            end
            if tracer.IsHitTracer and tracer.Light then
                tracer.Light.Range = 10 * val
            end
        end
    end
})

HitTracerGroup:AddSlider("HitTracerDuration", {
    Text = "duration",
    Default = 3,
    Min = 0.5,
    Max = 10,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        hitTracerDuration = val
        for _, tracer in ipairs(bulletTracers) do
            if tracer.IsHitTracer then
                tracer.Lifetime = val
                tracer.FadeStartTime = tracer.CreatedTime + val - hitTracerFadeTime
            end
        end
    end
})

HitTracerGroup:AddSlider("HitTracerFadeTime", {
    Text = "fade time",
    Default = 0.5,
    Min = 0.1,
    Max = 2,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        hitTracerFadeTime = val
        for _, tracer in ipairs(bulletTracers) do
            if tracer.IsHitTracer then
                tracer.FadeStartTime = tracer.CreatedTime + hitTracerDuration - val
            end
        end
    end
})

local ViewModelGroup = Tabs.World:AddRightGroupbox("viewmodel")

local gunChamsEnabled = false
local armChamsEnabled = false
local gunMaterial = Enum.Material.Neon
local armMaterial = Enum.Material.Neon
local gunColor = Color3.fromRGB(255, 255, 255)
local armColor = Color3.fromRGB(255, 255, 255)

local function applyChams()
    local viewModels = Workspace:FindFirstChild("ViewModels")
    if not viewModels then return end
    
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if not firstPerson then return end
    
    for _, model in ipairs(firstPerson:GetChildren()) do
        if model:IsA("Model") then
            for _, descendant in ipairs(model:GetDescendants()) do
                if descendant:IsA("BasePart") then
                    local partName = descendant.Name:lower()
                    
                    if gunChamsEnabled then
                        if not (partName == "leftarm" or partName == "rightarm") then
                            descendant.Material = gunMaterial
                            descendant.Color = gunColor
                            
                            for _, child in ipairs(descendant:GetChildren()) do
                                if child:IsA("Texture") or child:IsA("Decal") or child:IsA("SurfaceAppearance") then
                                    child.Transparency = 1
                                end
                            end
                        end
                    end
                    
                    if armChamsEnabled then
                        if partName == "leftarm" or partName == "rightarm" then
                            descendant.Material = armMaterial
                            descendant.Color = armColor
                            
                            for _, child in ipairs(descendant:GetChildren()) do
                                if child:IsA("Texture") or child:IsA("Decal") or child:IsA("SurfaceAppearance") then
                                    child.Transparency = 1
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

local chamLoop
local function startChamLoop()
    if chamLoop then
        chamLoop:Disconnect()
    end
    
    chamLoop = game:GetService("RunService").RenderStepped:Connect(function()
        applyChams()
    end)
end

local function stopChamLoop()
    if chamLoop then
        chamLoop:Disconnect()
        chamLoop = nil
    end
end

ViewModelGroup:AddToggle("GunChams", {
    Text = "gun chams",
    Default = false,
    Callback = function(val)
        gunChamsEnabled = val
        if gunChamsEnabled or armChamsEnabled then
            startChamLoop()
        else
            stopChamLoop()
        end
    end
}):AddColorPicker("GunColorPicker", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "gun color",
    Callback = function(val)
        gunColor = val
    end
})

ViewModelGroup:AddToggle("ArmChams", {
    Text = "arm chams",
    Default = false,
    Callback = function(val)
        armChamsEnabled = val
        if gunChamsEnabled or armChamsEnabled then
            startChamLoop()
        else
            stopChamLoop()
        end
    end
}):AddColorPicker("ArmColorPicker", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "arm color",
    Callback = function(val)
        armColor = val
    end
})

local materialOptions = {
    "ForceField",
    "Neon",
    "SmoothPlastic",
    "Glass",
    "Ice",
    "Plastic",
    "Wood",
    "Marble",
    "Granite",
    "Brick",
    "Cobblestone",
    "Concrete",
    "Slate",
    "Foil"
}

ViewModelGroup:AddDropdown("GunMaterial", {
    Text = "gun material",
    Default = "Neon",
    Values = materialOptions,
    Callback = function(val)
        gunMaterial = Enum.Material[val]
    end
})

ViewModelGroup:AddDropdown("ArmMaterial", {
    Text = "arm material",
    Default = "Neon",
    Values = materialOptions,
    Callback = function(val)
        armMaterial = Enum.Material[val]
    end
})

-- Bullet Tracers Groupbox
local TracersGroup = Tabs.World:AddLeftGroupbox("bullet tracers")

-- Tracer settings
local tracerEnabled = false
local tracerColor = Color3.fromRGB(255, 255, 255)
local tracerDuration = 3
local tracerSize = 1
local tracerFadeTime = 0.5
local tracerStyle = "Line"
local tracers = {}
local tracerConnection = nil
local lastTracerCreations = {}  -- Track tracers per shot to prevent exact duplicates

local textureAssets = {
    ["Line"] = "",
    ["Beam"] = "rbxassetid://12781852245",
    ["Lightning"] = "rbxassetid://446111271",
    ["Heartrate"] = "rbxassetid://5830549480",
    ["Chain"] = "rbxassetid://9632168658",
    ["Glitch"] = "rbxassetid://8089467613",
    ["Swirl"] = "rbxassetid://5638168605",
    ["Neon"] = "rbxassetid://6361963422",
    ["Plasma"] = "rbxassetid://8993645509",
    ["Laser"] = "rbxassetid://14549123968",
}

-- Function to get muzzle position
local function getMuzzlePosition()
    local viewModels = workspace:FindFirstChild("ViewModels")
    if not viewModels then return nil end
    
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if not firstPerson then return nil end
    
    local playerName = LocalPlayer.Name
    
    for _, model in pairs(firstPerson:GetChildren()) do
        if model:IsA("Model") and model.Name:find("^" .. playerName) then
            local itemVisual = model:FindFirstChild("ItemVisual")
            if itemVisual then
                local body = itemVisual:FindFirstChild("Body")
                if body then
                    local bodyPrimary = body:FindFirstChild("BodyPrimary")
                    if bodyPrimary then
                        local muzzle = bodyPrimary:FindFirstChild("_muzzle")
                        if muzzle and muzzle:IsA("Attachment") then
                            return muzzle.WorldPosition
                        end
                    end
                end
            end
        end
    end
    
    return nil
end

-- Function to create a segmented tracer (supports both Line and Beam styles)
local function createTracer(startPos, endPos)
    if not startPos or not endPos then return end
    
    -- PREVENT EXACT DUPLICATES ONLY (same position within 0.01 studs)
    local posKey = string.format("%.2f_%.2f_%.2f_%.2f_%.2f_%.2f", 
        startPos.X, startPos.Y, startPos.Z, 
        endPos.X, endPos.Y, endPos.Z)
    
    local currentTime = tick()
    if lastTracerCreations[posKey] and (currentTime - lastTracerCreations[posKey]) < 0.1 then
        return  -- Skip exact duplicate within 100ms
    end
    lastTracerCreations[posKey] = currentTime
    
    -- Clean old entries to prevent memory leak
    for key, time in pairs(lastTracerCreations) do
        if currentTime - time > 1 then
            lastTracerCreations[key] = nil
        end
    end
    
    -- Check if using Line style (2D segments) or Beam style (3D beams)
    if tracerStyle == "Line" then
        -- Create segmented 2D line (fractured into parts)
        local direction = (endPos - startPos)
        local distance = direction.Magnitude
        local segmentLength = 5
        local numSegments = math.ceil(distance / segmentLength)
        
        local segments = {}
        
        for i = 1, numSegments do
            local segStart = startPos + (direction.Unit * ((i - 1) * segmentLength))
            local segEnd = startPos + (direction.Unit * math.min(i * segmentLength, distance))
            
            local line = Drawing.new("Line")
            line.Thickness = 2 * tracerSize
            line.Color = tracerColor
            line.Transparency = 1  -- Fully visible
            line.Visible = false
            
            table.insert(segments, {
                Line = line,
                StartPos = segStart,
                EndPos = segEnd
            })
        end
        
        local tracer = {
            Segments = segments,
            Lifetime = tracerDuration,
            CreatedTime = tick(),
            FadeTime = tracerFadeTime,
            StartPos = startPos,
            EndPos = endPos,
            IsLine = true
        }
        
        table.insert(tracers, tracer)
    else
        -- Create 3D Beam with texture
        local attachment0 = Instance.new("Attachment")
        attachment0.Position = Vector3.new(0, 0, 0)
        attachment0.Parent = workspace.Terrain
        
        local attachment1 = Instance.new("Attachment")
        attachment1.Position = Vector3.new(0, 0, 0)
        attachment1.Parent = workspace.Terrain
        
        local beam = Instance.new("Beam")
        beam.Attachment0 = attachment0
        beam.Attachment1 = attachment1
        beam.Color = ColorSequence.new(tracerColor)
        
        local baseWidth = tracerStyle == "Laser" and 0.02 or 0.15
        beam.Width0 = baseWidth * tracerSize
        beam.Width1 = baseWidth * tracerSize
        beam.Transparency = NumberSequence.new(0)
        beam.FaceCamera = true
        beam.LightEmission = 0.8
        beam.LightInfluence = 0.2
        
        -- Apply texture
        local texture = textureAssets[tracerStyle]
        if texture and texture ~= "" then
            beam.Texture = texture
            beam.TextureLength = 4
            beam.TextureSpeed = 1
        else
            beam.Texture = ""
            beam.TextureLength = 1
            beam.TextureSpeed = 0
        end
        
        beam.Parent = workspace.Terrain
        
        attachment0.WorldPosition = startPos
        attachment1.WorldPosition = endPos
        
        local tracer = {
            Beam = beam,
            Attachment0 = attachment0,
            Attachment1 = attachment1,
            Lifetime = tracerDuration,
            CreatedTime = tick(),
            FadeTime = tracerFadeTime,
            IsLine = false
        }
        
        table.insert(tracers, tracer)
    end
end

-- Function to update tracers (OPTIMIZED - handles both Line and Beam)
local function updateTracers()
    if #tracers == 0 then return end  -- Skip if no tracers
    
    local currentTime = tick()
    local camera = workspace.CurrentCamera
    local myChar = LocalPlayer.Character
    local myPos = myChar and myChar:FindFirstChild("HumanoidRootPart") and myChar.HumanoidRootPart.Position
    
    -- Process tracers in reverse to safely remove
    for i = #tracers, 1, -1 do
        local tracer = tracers[i]
        if not tracer then
            table.remove(tracers, i)
            continue
        end
        
        local age = currentTime - tracer.CreatedTime
        
        -- Remove tracer if lifetime exceeded
        if age >= tracer.Lifetime then
            if tracer.IsLine and tracer.Segments then
                for _, segment in ipairs(tracer.Segments) do
                    if segment.Line then
                        segment.Line:Remove()
                    end
                end
            elseif not tracer.IsLine then
                if tracer.Beam then tracer.Beam:Destroy() end
                if tracer.Attachment0 then tracer.Attachment0:Destroy() end
                if tracer.Attachment1 then tracer.Attachment1:Destroy() end
            end
            table.remove(tracers, i)
        else
            -- Calculate fade once per tracer
            local fadeAlpha
            if age >= (tracer.Lifetime - tracer.FadeTime) then
                local fadeProgress = (age - (tracer.Lifetime - tracer.FadeTime)) / tracer.FadeTime
                fadeAlpha = 1 - math.clamp(fadeProgress, 0, 1)
            else
                fadeAlpha = 1
            end
            
            if tracer.IsLine and tracer.Segments then
                -- Update Line segments (2D)
                for _, segment in ipairs(tracer.Segments) do
                    local shouldShow = false
                    local fromPos, toPos
                    
                    local success = pcall(function()
                        if myPos then
                            local distToStart = (segment.StartPos - myPos).Magnitude
                            if distToStart < 2 then return end
                        end
                        
                        local segmentStart, onScreenStart = camera:WorldToViewportPoint(segment.StartPos)
                        local segmentEnd, onScreenEnd = camera:WorldToViewportPoint(segment.EndPos)
                        
                        if segmentStart.Z <= 0 or segmentEnd.Z <= 0 then return end
                        if not (segmentStart.X and segmentStart.Y and segmentEnd.X and segmentEnd.Y) then return end
                        if math.abs(segmentStart.X) > 20000 or math.abs(segmentStart.Y) > 20000 or 
                           math.abs(segmentEnd.X) > 20000 or math.abs(segmentEnd.Y) > 20000 then
                            return
                        end
                        
                        fromPos = Vector2.new(segmentStart.X, segmentStart.Y)
                        toPos = Vector2.new(segmentEnd.X, segmentEnd.Y)
                        
                        local lineLength = (toPos - fromPos).Magnitude
                        if lineLength < 3000 and lineLength > 0.1 then
                            shouldShow = true
                        end
                    end)
                    
                    if success and shouldShow and fromPos and toPos then
                        segment.Line.From = fromPos
                        segment.Line.To = toPos
                        segment.Line.Visible = true
                        segment.Line.Transparency = fadeAlpha
                    else
                        segment.Line.Visible = false
                    end
                end
            elseif not tracer.IsLine and tracer.Beam then
                -- Update Beam (3D) - just update transparency
                tracer.Beam.Transparency = NumberSequence.new(1 - fadeAlpha)
            end
        end
    end
end

-- Hook into the Gun class to detect shooting immediately
local function startTracers()
    if tracerConnection then
        tracerConnection:Disconnect()
    end
    
    -- Clear any existing tracers
    for _, tracer in ipairs(tracers) do
        if tracer.Segments then
            for _, segment in ipairs(tracer.Segments) do
                if segment.Line then
                    segment.Line:Remove()
                end
            end
        end
    end
    tracers = {}
    
    -- PRIMARY: Hook TracerEffect - THIS IS THE MOST ACCURATE
    pcall(function()
        local TracerEffect = require(LocalPlayer.PlayerScripts.Modules.TracerEffect)
        local originalPlay = TracerEffect.Play
        
        TracerEffect.Play = function(self, tracerData, config, extraData)
            -- CRITICAL: Only for LOCAL PLAYER (tracerData.IsLocal check)
            if not tracerEnabled then return originalPlay(self, tracerData, config, extraData) end
            if not tracerData or not tracerData.IsLocal then 
                return originalPlay(self, tracerData, config, extraData)
            end
            
            -- Use game's own raycast results for perfect accuracy
            if tracerData.RaycastResults then
                local muzzlePos = getMuzzlePosition()
                
                if muzzlePos then
                    -- Loop through ALL hits (for shotguns with multiple pellets)
                    for _, hit in ipairs(tracerData.RaycastResults) do
                        if hit.Position then
                            createTracer(muzzlePos, hit.Position)
                        end
                    end
                end
            end
            
            return originalPlay(self, tracerData, config, extraData)
        end
    end)
    
    -- Start updating tracers every frame
    tracerConnection = game:GetService("RunService").RenderStepped:Connect(updateTracers)
end

local function stopTracers()
    if tracerConnection then
        tracerConnection:Disconnect()
        tracerConnection = nil
    end
    
    -- Clean up all tracers (both Line and Beam)
    for _, tracer in ipairs(tracers) do
        if tracer.IsLine and tracer.Segments then
            for _, segment in ipairs(tracer.Segments) do
                if segment.Line then
                    segment.Line:Remove()
                end
            end
        elseif not tracer.IsLine then
            if tracer.Beam then tracer.Beam:Destroy() end
            if tracer.Attachment0 then tracer.Attachment0:Destroy() end
            if tracer.Attachment1 then tracer.Attachment1:Destroy() end
        end
    end
    tracers = {}
end

-- Toggle for tracers
TracersGroup:AddToggle("TracerEnabled", {
    Text = "enable tracers",
    Default = false,
    Callback = function(val)
        tracerEnabled = val
        if tracerEnabled then
            startTracers()
        else
            stopTracers()
        end
    end
}):AddColorPicker("TracerColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "tracer color",
    Callback = function(val)
        tracerColor = val
        -- Update existing tracers
        for _, tracer in ipairs(tracers) do
            if tracer.IsLine and tracer.Segments then
                for _, segment in ipairs(tracer.Segments) do
                    if segment.Line then
                        segment.Line.Color = val
                    end
                end
            elseif not tracer.IsLine and tracer.Beam then
                tracer.Beam.Color = ColorSequence.new(val)
            end
        end
    end
})

-- Style dropdown
TracersGroup:AddDropdown("TracerStyle", {
    Text = "style",
    Default = "Line",
    Values = {"Line", "Beam", "Lightning", "Heartrate", "Chain", "Glitch", "Swirl", "Neon", "Plasma", "Laser"},
    Callback = function(val)
        tracerStyle = val
    end
})

-- Duration slider (how long tracer stays fully visible)
TracersGroup:AddSlider("TracerDuration", {
    Text = "duration",
    Default = 3,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        tracerDuration = val
        -- Update existing tracers
        for _, tracer in ipairs(tracers) do
            if tracer then
                tracer.Lifetime = val
            end
        end
    end
})

-- Size slider
TracersGroup:AddSlider("TracerSize", {
    Text = "size",
    Default = 1,
    Min = 0.5,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        tracerSize = val
        -- Update existing tracers
        for _, tracer in ipairs(tracers) do
            if tracer.IsLine and tracer.Segments then
                for _, segment in ipairs(tracer.Segments) do
                    if segment.Line then
                        segment.Line.Thickness = 2 * val
                    end
                end
            elseif not tracer.IsLine and tracer.Beam then
                local baseWidth = tracerStyle == "Laser" and 0.02 or 0.15
                tracer.Beam.Width0 = baseWidth * val
                tracer.Beam.Width1 = baseWidth * val
            end
        end
    end
})

-- Fade time slider (how long fade-out animation takes)
TracersGroup:AddSlider("TracerFade", {
    Text = "fade time",
    Default = 0.5,
    Min = 0,
    Max = 2,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        tracerFadeTime = val
        -- Update existing tracers
        for _, tracer in ipairs(tracers) do
            if tracer then
                tracer.FadeTime = val
            end
        end
    end
})

local SoundGroup = Tabs.World:AddLeftGroupbox("hit sounds")

SoundGroup:AddToggle("HitSounds", {
    Text = "enable",
    Default = false,
    Callback = function(val)
        hitSoundEnabled = val
    end
})

SoundGroup:AddDropdown("SoundStyleDropdown", {
    Text = "sound",
    Default = "Rust HS",
    Values = {"Rust HS", "Neverlose", "Minecraft Bow", "Minecraft Hit", "CSGO"},
    Callback = function(val)
        hitSoundStyle = val
    end
})

SoundGroup:AddSlider("SoundVolume", {
    Text = "volume",
    Default = 50,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Compact = true,
    Callback = function(val)
        hitSoundVolume = val / 100
    end
})

SoundGroup:AddSlider("SoundPitch", {
    Text = "pitch",
    Default = 100,
    Min = 50,
    Max = 200,
    Rounding = 0,
    Compact = true,
    Callback = function(val)
        hitSoundPitch = val / 100
    end
})

game:GetService("ScriptContext").DescendantRemoving:Connect(function(descendant)
    if descendant == script then
        Utility.Raycast = OriginalRaycast
        fovCircle:Remove()
        
        for _, tracer in ipairs(bulletTracers) do
            if tracer.Line then
                tracer.Line:Destroy()
            end
            if tracer.Attachment0 then
                tracer.Attachment0:Destroy()
            end
            if tracer.Attachment1 then
                tracer.Attachment1:Destroy()
            end
            if tracer.Light then
                tracer.Light:Destroy()
            end
        end
        bulletTracers = {}
    end
end)

LocalPlayer.CharacterRemoving:Connect(function()
    if silentAimEnabled then
        Utility.Raycast = OriginalRaycast
        task.wait(1)
        if silentAimEnabled then
            Utility.Raycast = silentAimRaycast
        end
    end
end)

local replicated_storage = cloneref(game:GetService("ReplicatedStorage"))
local players = game:GetService("Players")
local run_service = game:GetService("RunService")
local user_input = game:GetService("UserInputService")
local workspace = game:GetService("Workspace")

local player = players.LocalPlayer
local camera = workspace.CurrentCamera

local modules = {
    enums = require(replicated_storage.Modules.EnumLibrary),
    fighter = require(player.PlayerScripts.Controllers.FighterController),
    camcontrol = require(player.PlayerScripts.Controllers.CameraController)
}

local config = {
    target = {
        enabled = false,
        character = nil,
        auto = false,
        autoshoot = false,
        hitpart = "Head",
        lastchar = nil,
        lastplayer = nil,
        manualkey = false
    },
    prediction = {
        enabled = false,
        multiplier = 1.2,
        velocity = Vector3.new(0, 0, 0),
        acceleration = Vector3.new(0, 0, 0),
        lastposition = nil,
        lasttime = 0,
        velbuffer = {},
        posbuffer = {},
        maxvelsamples = 15,
        maxpossamples = 5
    },
    orbit = {
        active = false,
        angle = 0,
        frozencf = nil,
        visualhrp = nil,
        serverpos = nil,
        connection = nil,
        speed = 9000,
        height = -1,
        radius = 0,
        originalpos = nil
    },
    state = {
        reloading = false,
        outofammo = false,
        csyncactive = false,
        ismelee = false
    },
    -- NEW: Orb collection config
    orbs = {
        collectHealth = true,
        collectAmmo = true,
        collecting = false,
        currentOrb = nil,
        orbsInArea = {}
    },
    -- NEW: Voidhide config
    voidhide = {
        enabled = false,
        skyPosition = Vector3.new(0, 999999999, 0),
        originalPosition = nil,
        active = false,
        checkCooldown = 0,
        checkInterval = 0.5
    },
    -- NEW: Visualizer config
    visualizer = {
        enabled = false,
        tracer = {
            color = Color3.fromRGB(0, 186, 255),
            thickness = 1,
            transparency = 1,
            start_point = "cursor", -- "cursor" or "muzzle"
            outline = true,
            outline_color = Color3.fromRGB(0, 0, 0),
            outline_thickness = 1
        },
        indicator = {
            display_options = {"name", "position", "hit reg"}, -- "name", "position", "hit_reg"
            color = Color3.fromRGB(255, 255, 255),
            accent_color = Color3.fromRGB(0, 186, 255)
        }
    }
}

local trackhealth = {}
local localfighter = modules.fighter.LocalFighter
local oldpos

local indicator = Drawing.new("Circle")
indicator.Thickness = 1.5
indicator.NumSides = 36
indicator.Filled = false
indicator.Transparency = 1
indicator.Visible = false
indicator.Radius = 12
indicator.Color = Color3.fromRGB(255, 50, 50)

local indicator_outline = Drawing.new("Circle")
indicator_outline.Thickness = 4
indicator_outline.NumSides = 36
indicator_outline.Filled = false
indicator_outline.Transparency = 1
indicator_outline.Visible = false
indicator_outline.Radius = 12
indicator_outline.Color = Color3.fromRGB(0, 0, 0)

local tracer_line = Drawing.new("Line")
tracer_line.Visible = false
tracer_line.Thickness = 2
tracer_line.Transparency = 1
tracer_line.Color = Color3.fromRGB(0, 186, 255)

local tracer_outline = Drawing.new("Line")
tracer_outline.Visible = false
tracer_outline.Thickness = 4
tracer_outline.Transparency = 1
tracer_outline.Color = Color3.fromRGB(0, 0, 0)

local ind_text1 = Drawing.new("Text")
ind_text1.Size = 13
ind_text1.Font = 2
ind_text1.Outline = true
ind_text1.Text = ""
ind_text1.Color = Color3.new(1, 1, 1)
ind_text1.Visible = false
ind_text1.Center = true

local ind_text2 = Drawing.new("Text")
ind_text2.Size = 13
ind_text2.Font = 2
ind_text2.Outline = true
ind_text2.Text = ""
ind_text2.Color = Color3.fromRGB(0, 186, 255)
ind_text2.Visible = false
ind_text2.Center = true

local last_damage_time = {}

local oldcamupdate = modules.camcontrol.Update
modules.camcontrol.Update = function(...)
    local arguments = {...}
    if config.state.csyncactive and localfighter and localfighter.Entity.RootPart and oldpos then
        localfighter.Entity.RootPart.CFrame = oldpos
    end
    return oldcamupdate(table.unpack(arguments))
end

local function drawind()
    -- Check if visualizer is enabled
    if config.visualizer and config.visualizer.enabled 
       and config.target and config.target.enabled and config.target.character then
        
        local root = config.target.character:FindFirstChild("HumanoidRootPart")
        if root then
            local pos, visible = camera:WorldToViewportPoint(root.Position)
            if visible then
                -- Update tracer
                if config.visualizer.tracer then
                    local startPos
                    if config.visualizer.tracer.start_point == "muzzle" then
                        local muzzlePos = getMuzzlePosition()
                        if muzzlePos then
                            local muzzleScreen = camera:WorldToViewportPoint(muzzlePos)
                            startPos = Vector2.new(muzzleScreen.X, muzzleScreen.Y)
                        else
                            startPos = user_input:GetMouseLocation()
                        end
                    else
                        startPos = user_input:GetMouseLocation()
                    end
                    
                    -- Draw tracer outline (thinner appearance)
                    if config.visualizer.tracer.outline then
                        tracer_outline.From = startPos
                        tracer_outline.To = Vector2.new(pos.X, pos.Y)
                        tracer_outline.Thickness = config.visualizer.tracer.outline_thickness or 1
                        tracer_outline.Color = config.visualizer.tracer.outline_color or Color3.new(0, 0, 0)
                        tracer_outline.Transparency = config.visualizer.tracer.transparency or 0
                        tracer_outline.Visible = true
                    else
                        tracer_outline.Visible = false
                    end
                    
                    -- Draw tracer (thinner appearance)
                    tracer_line.From = startPos
                    tracer_line.To = Vector2.new(pos.X, pos.Y)
                    tracer_line.Thickness = config.visualizer.tracer.thickness or 0.5  -- Made thinner
                    tracer_line.Color = config.visualizer.tracer.color or Color3.new(1, 1, 1)
                    tracer_line.Transparency = config.visualizer.tracer.transparency or 0
                    tracer_line.Visible = true
                else
                    tracer_line.Visible = false
                    tracer_outline.Visible = false
                end
                
                -- Update indicator with dropdown options
                if config.visualizer.indicator then
                    local targetPlayer = players:GetPlayerFromCharacter(config.target.character)
                    local displayOptions = config.visualizer.indicator.display_options or {}
                    local parts = {}
                    
                    -- Check each display option
                    for _, option in pairs(displayOptions) do
                        if option == "name" and targetPlayer then
                            table.insert(parts, targetPlayer.Name)
                        elseif option == "position" then
                            local targetPos = root.Position
                            table.insert(parts, string.format("%.0f, %.0f, %.0f", targetPos.X, targetPos.Y, targetPos.Z))
                        elseif option == "hit reg" and targetPlayer then
                            local lastTime = last_damage_time[targetPlayer] or 0
                            local elapsed = tick() - lastTime
                            table.insert(parts, string.format("%.1fs", elapsed))
                        end
                    end
                    
                    if #parts > 0 then
                        local fullText = table.concat(parts, " | ")
                        local pipeCount = 0
                        local text1Parts = {}
                        local text2Parts = {}
                        
                        for part in fullText:gmatch("[^|]+") do
                            if pipeCount % 2 == 0 then
                                table.insert(text1Parts, part)
                            else
                                table.insert(text2Parts, part)
                            end
                            pipeCount = pipeCount + 1
                        end
                        
                        -- Build alternating text
                        local finalText1 = ""
                        local finalText2 = ""
                        local building1 = true
                        
                        for char in fullText:gmatch(".") do
                            if char == "|" then
                                finalText1 = finalText1 .. char
                                finalText2 = finalText2 .. char
                                building1 = not building1
                            else
                                if building1 then
                                    finalText1 = finalText1 .. char
                                    finalText2 = finalText2 .. " "
                                else
                                    finalText1 = finalText1 .. " "
                                    finalText2 = finalText2 .. char
                                end
                            end
                        end
                        
                        local screenCenter = camera.ViewportSize / 2
                        
                        ind_text1.Text = finalText1
                        ind_text1.Color = config.visualizer.indicator.color or Color3.new(1, 1, 1)
                        ind_text1.Position = Vector2.new(screenCenter.X, screenCenter.Y)
                        ind_text1.Visible = true
                        
                        ind_text2.Text = finalText2
                        ind_text2.Color = config.visualizer.indicator.accent_color or Color3.new(1, 0, 0)
                        ind_text2.Position = Vector2.new(screenCenter.X, screenCenter.Y)
                        ind_text2.Visible = true
                    else
                        ind_text1.Visible = false
                        ind_text2.Visible = false
                    end
                else
                    ind_text1.Visible = false
                    ind_text2.Visible = false
                end
                
                return
            end
        end
    end
    
    tracer_line.Visible = false
    tracer_outline.Visible = false
    ind_text1.Visible = false
    ind_text2.Visible = false
end


local function getweapon()
    local viewmodels = workspace:FindFirstChild("ViewModels")
    if not viewmodels then return end
    
    local firstperson = viewmodels:FindFirstChild("FirstPerson")
    if not firstperson then return end
    
    for _, child in ipairs(firstperson:GetChildren()) do
        local parts = {}
        for part in child.Name:gmatch("[^-]+") do
            table.insert(parts, part:match("^%s*(.-)%s*$"))
        end
        if #parts >= 2 then
            return parts[2]
        end
    end
end

local function getMuzzlePosition()
    local viewModels = workspace:FindFirstChild("ViewModels")
    if not viewModels then return nil end
    
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if not firstPerson then return nil end
    
    local playerName = player.Name
    
    for _, model in pairs(firstPerson:GetChildren()) do
        if model:IsA("Model") and model.Name:find("^" .. playerName) then
            local itemVisual = model:FindFirstChild("ItemVisual")
            if itemVisual then
                local body = itemVisual:FindFirstChild("Body")
                if body then
                    local bodyPrimary = body:FindFirstChild("BodyPrimary")
                    if bodyPrimary then
                        local muzzle = bodyPrimary:FindFirstChild("_muzzle")
                        if muzzle and muzzle:IsA("Attachment") then
                            return muzzle.WorldPosition
                        end
                    end
                end
            end
        end
    end
    
    return nil
end

local function getammo()
    local success, controller = pcall(function()
        return require(player.PlayerScripts.Controllers.FighterController)
    end)
    
    if success and controller then
        local fighter = controller.LocalFighter
        if fighter then
            local item = fighter.EquippedItem
            if item then
                local current = item:Get("CurrentAmmo") or item:Get("Ammo")
                local max = item:Get("MaxAmmo")
                
                if current == nil and max == nil then
                    return 1, 1, true
                elseif current and max then
                    return current, max, false
                elseif current then
                    return current, current, false
                else
                    return 0, 0, false
                end
            end
        end
    end
    
    return 0, 0, false
end

local function isteammate(targetplayer)
    if not targetplayer then return false end
    
    local localTeamID = player:GetAttribute("TeamID")
    local targetTeamID = targetplayer:GetAttribute("TeamID")
    
    if localTeamID and targetTeamID and localTeamID == targetTeamID then
        return true
    end
    
    return false
end

local function valid(char)
    if not char or not char.Parent then return false end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return false end
    
    local targetplayer = players:GetPlayerFromCharacter(char)
    if not targetplayer then return false end
    
    if isteammate(targetplayer) then return false end
    
    return true
end

local function nearest()
    local cursorpos = user_input:GetMouseLocation()
    local besttarget = nil
    local bestdistance = math.huge
    
    for _, targetplayer in players:GetPlayers() do
        if targetplayer ~= player and targetplayer.Character then
            local char = targetplayer.Character
            if valid(char) then
                local root = char:FindFirstChild("HumanoidRootPart")
                if root then
                    local screenpos, onscreen = camera:WorldToViewportPoint(root.Position)
                    if onscreen then
                        local distance = (Vector2.new(screenpos.X, screenpos.Y) - cursorpos).Magnitude
                        if distance < bestdistance then
                            besttarget = char
                            bestdistance = distance
                        end
                    end
                end
            end
        end
    end
    
    return besttarget
end

local function updatevel()
    if not config.target.character or not config.prediction.enabled then
        config.prediction.velocity = Vector3.new(0, 0, 0)
        config.prediction.acceleration = Vector3.new(0, 0, 0)
        config.prediction.lastposition = nil
        config.prediction.velbuffer = {}
        config.prediction.posbuffer = {}
        return
    end
    
    local root = config.target.character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    local now = tick()
    local dt = now - config.prediction.lasttime
    
    if dt > 0 and dt < 0.1 then
        local currentpos = root.Position
        
        table.insert(config.prediction.posbuffer, 1, {
            position = currentpos,
            time = now
        })
        if #config.prediction.posbuffer > config.prediction.maxpossamples then
            table.remove(config.prediction.posbuffer)
        end
        
        if config.prediction.lastposition then
            local instantvel = (currentpos - config.prediction.lastposition) / dt
            
            if config.prediction.velocity.Magnitude > 0.1 then
                local instantaccel = (instantvel - config.prediction.velocity) / dt
                config.prediction.acceleration = config.prediction.acceleration:Lerp(instantaccel, 0.5)
            end
            
            table.insert(config.prediction.velbuffer, 1, {
                velocity = instantvel,
                time = now,
                dt = dt
            })
            
            if #config.prediction.velbuffer > config.prediction.maxvelsamples then
                table.remove(config.prediction.velbuffer)
            end
            
            if #config.prediction.velbuffer > 0 then
                local weightedsum = Vector3.new(0, 0, 0)
                local totalweight = 0
                
                for i, entry in ipairs(config.prediction.velbuffer) do
                    local weight = math.exp(-(i-1) * 0.3)
                    weightedsum = weightedsum + (entry.velocity * weight)
                    totalweight = totalweight + weight
                end
                
                config.prediction.velocity = weightedsum / totalweight
            else
                config.prediction.velocity = instantvel
            end
        end
        
        config.prediction.lastposition = currentpos
        config.prediction.lasttime = now
    end
end

local function predict(targetpart, origin)
    if not config.prediction.enabled or not targetpart then
        return targetpart.Position
    end
    
    local basepos = targetpart.Position
    local distance = (basepos - origin).Magnitude
    
    local ping = 0
    pcall(function()
        ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    end)
    
    local bulletspeed = 3000
    local traveltime = distance / bulletspeed
    
    local speed = config.prediction.velocity.Magnitude
    
    local adaptivemult = 1.0
    if speed > 150 then
        adaptivemult = 1.5 + math.min((speed - 150) / 300, 1.0)
    elseif speed > 80 then
        adaptivemult = 1.3
    elseif speed > 40 then
        adaptivemult = 1.1
    elseif speed < 10 then
        adaptivemult = 0.7
    end
    
    local totaltime = (traveltime + ping) * config.prediction.multiplier * adaptivemult
    
    local predicted = basepos + (config.prediction.velocity * totaltime)
    
    if config.prediction.acceleration.Magnitude > 5 and speed > 50 then
        local accelcontrib = config.prediction.acceleration * (totaltime * totaltime * 0.5)
        predicted = predicted + accelcontrib
    end
    
    if #config.prediction.posbuffer >= 3 then
        local jittersum = Vector3.new(0, 0, 0)
        for i = 1, math.min(3, #config.prediction.posbuffer - 1) do
            local diff = config.prediction.posbuffer[i].position - 
                        config.prediction.posbuffer[i+1].position
            jittersum = jittersum + diff
        end
        local avgjitter = jittersum / math.min(3, #config.prediction.posbuffer - 1)
        
        if avgjitter.Magnitude > 2 then
            predicted = predicted + (avgjitter * 0.3)
        end
    end
    
    if math.abs(config.prediction.velocity.Y) > 5 then
        local verticalboost = config.prediction.velocity.Y * totaltime * 0.15
        predicted = predicted + Vector3.new(0, verticalboost, 0)
    end
    
    return predicted
end

local function canuse()
    local char = player.Character
    if not char then return false end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    local current, max, melee = getammo()
    
    if current <= 0 and not melee then
        return false
    end
    
    return true
end

-- NEW: Find nearby orbs
local function findNearbyOrbs()
    local orbs = {}
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return orbs end
    
    local hrp = char.HumanoidRootPart
    local humanoid = char:FindFirstChild("Humanoid")
    local needsHealth = humanoid and humanoid.Health < humanoid.MaxHealth
    
    for _, obj in workspace:GetChildren() do
        if obj.Name == "_drop" and obj:IsA("BasePart") then
            local isHealth = obj:FindFirstChild("Health")
            local isAmmo = obj:FindFirstChild("Ammo")
            
            if (config.orbs.collectHealth and isHealth and needsHealth) or 
               (config.orbs.collectAmmo and isAmmo) then
                table.insert(orbs, obj)
            end
        end
    end
    
    return orbs
end

-- NEW: Collect orbs while in csync
local function collectOrbsWhileReloading()
    if not config.state.reloading or not config.state.csyncactive then return end
    if not localfighter or not localfighter.Entity.RootPart then return end
    
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = char.HumanoidRootPart
    local nearbyOrbs = findNearbyOrbs()
    
    if #nearbyOrbs > 0 then
        config.orbs.collecting = true
        
        -- Find closest orb
        local closestOrb = nil
        local closestDist = math.huge
        local currentPos = config.orbit.serverpos or hrp.Position
        
        for _, orb in ipairs(nearbyOrbs) do
            local dist = (orb.Position - currentPos).Magnitude
            if dist < closestDist then
                closestOrb = orb
                closestDist = dist
            end
        end
        
        if closestOrb then
            config.orbs.currentOrb = closestOrb
            -- Teleport to orb position in csync
            local orbPos = closestOrb.Position + Vector3.new(0, 2, 0)
            config.orbit.serverpos = orbPos
            localfighter.Entity.RootPart.CFrame = CFrame.new(orbPos)
            
            -- Fire touch to collect
            task.spawn(function()
                for i = 1, 3 do
                    if closestOrb and closestOrb.Parent then
                        firetouchinterest(hrp, closestOrb, 0)
                        firetouchinterest(hrp, closestOrb, 1)
                    end
                    task.wait(0.05)
                end
            end)
        end
    else
        config.orbs.collecting = false
        config.orbs.currentOrb = nil
    end
end

-- NEW: Basic orb collection (always active when auto target is on)
local function collectOrbsBasic()
    if not config.target.auto then return end
    
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = char.HumanoidRootPart
    local humanoid = char:FindFirstChild("Humanoid")
    local needsHealth = humanoid and humanoid.Health < humanoid.MaxHealth
    
    for _, obj in workspace:GetChildren() do
        if obj.Name == "_drop" and obj:IsA("BasePart") then
            if (config.orbs.collectHealth and obj:FindFirstChild("Health") and needsHealth) or 
               (config.orbs.collectAmmo and obj:FindFirstChild("Ammo")) then
                firetouchinterest(hrp, obj, 0)
                firetouchinterest(hrp, obj, 1)
            end
        end
    end
end

local function startsync()
    if config.state.csyncactive then return end
    
    local char = player.Character
    if not char then return end
    
    if not localfighter or not localfighter.Entity.RootPart then return end
    
    config.state.csyncactive = true
    config.orbit.active = true
    
    -- Adjust height based on weapon
    local weapon = getweapon()
    if weapon and weapon:lower():find("sniper") then
        config.orbit.height = 8
    else
        config.orbit.height = 2
    end
    
    config.orbit.connection = run_service.Heartbeat:Connect(function(dt)
        if not config.state.csyncactive then
            if config.orbit.connection then
                config.orbit.connection:Disconnect()
                config.orbit.connection = nil
            end
            return
        end
        
        -- Check localfighter first to avoid nil index error
        if not localfighter or not localfighter.Entity or not localfighter.Entity.RootPart then
            if config.orbit.connection then
                config.orbit.connection:Disconnect()
                config.orbit.connection = nil
            end
            
            config.state.csyncactive = false
            config.orbit.active = false
            oldpos = nil
            config.orbit.serverpos = nil
            return
        end
        
        if not config.target.character or not config.target.character.Parent or 
           not config.target.character:FindFirstChild("HumanoidRootPart") then
            
            if config.orbit.connection then
                config.orbit.connection:Disconnect()
                config.orbit.connection = nil
            end
            
            config.state.csyncactive = false
            config.orbit.active = false
            oldpos = nil
            config.orbit.serverpos = nil
            return
        end
        
        oldpos = localfighter.Entity.RootPart.CFrame
        config.orbit.originalpos = oldpos
        
        -- NEW: If reloading and collecting orbs, handle that separately
        if config.state.reloading then
            collectOrbsWhileReloading()
            -- Don't override position if we're collecting orbs
            if not config.orbs.collecting then
                local targetpos = config.target.character.HumanoidRootPart.Position
                config.orbit.angle = config.orbit.angle + (config.orbit.speed * dt)
                
                local offset = Vector3.new(
                    math.cos(config.orbit.angle) * config.orbit.radius,
                    config.orbit.height,
                    math.sin(config.orbit.angle) * config.orbit.radius
                )
                
                config.orbit.serverpos = targetpos + offset
                localfighter.Entity.RootPart.CFrame = CFrame.new(config.orbit.serverpos)
            end
        else
            -- Normal orbit behavior
            local targetpos = config.target.character.HumanoidRootPart.Position
            config.orbit.angle = config.orbit.angle + (config.orbit.speed * dt)
            
            local offset = Vector3.new(
                math.cos(config.orbit.angle) * config.orbit.radius,
                config.orbit.height,
                math.sin(config.orbit.angle) * config.orbit.radius
            )
            
            config.orbit.serverpos = targetpos + offset
            localfighter.Entity.RootPart.CFrame = CFrame.new(config.orbit.serverpos)
        end
    end)
end

local function stopsync()
    if not config.state.csyncactive then return end
    
    if config.orbit.connection then
        config.orbit.connection:Disconnect()
        config.orbit.connection = nil
    end
    
    if localfighter and localfighter.Entity.RootPart and config.orbit.originalpos then
        localfighter.Entity.RootPart.CFrame = config.orbit.originalpos
    end
    
    config.state.csyncactive = false
    config.orbit.active = false
    oldpos = nil
    config.orbit.serverpos = nil
    config.orbit.originalpos = nil
    config.orbs.collecting = false
    config.orbs.currentOrb = nil
end

-- NEW: Helper function to get target hitpart
local function getHitPartFromName(character, partname)
    if partname == "Closest" then
        local mychar = player.Character
        if not mychar or not mychar:FindFirstChild("HumanoidRootPart") then
            return character:FindFirstChild("Head")
        end
        
        local mypos = mychar.HumanoidRootPart.Position
        local closest = nil
        local closestdist = math.huge
        
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                local dist = (part.Position - mypos).Magnitude
                if dist < closestdist then
                    closest = part
                    closestdist = dist
                end
            end
        end
        
        return closest or character:FindFirstChild("Head")
    elseif partname == "Random" then
        local parts = {"Head", "HumanoidRootPart", "Torso", "UpperTorso"}
        local randompart = parts[math.random(1, #parts)]
        return character:FindFirstChild(randompart) or character:FindFirstChild("Head")
    else
        return character:FindFirstChild(partname) or character:FindFirstChild("Head")
    end
end

-- MODIFIED: Raycast hook that works for both manual and auto shooting
local function raymod(...)
    if not config.target.enabled or not config.target.character then
        return OriginalRaycast(...)
    end
    
    if math.random(1, 100) > (hitChance or 100) then
        return OriginalRaycast(...)
    end
    
    local args = {...}
    local hitpart = getHitPartFromName(config.target.character, config.target.hitpart)
    
    if hitpart then
        local mychar = player.Character
        local mypos = mychar and mychar:FindFirstChild("HumanoidRootPart")
        
        if mypos then
            local shootpos = config.state.csyncactive and oldpos and oldpos.Position or mypos.Position
            local pred = predict(hitpart, shootpos)
            args[3] = pred
        end
    end
    
    return OriginalRaycast(table.unpack(args))
end

local OldGunStartShooting = nil
local OldGetMouseLocation = nil
local targetDamageTracker = {}

local function hookGunMethods()
    if not modules.fighter or not modules.fighter.LocalFighter then return end
    
    local item = modules.fighter.LocalFighter.EquippedItem
    if not item or not item.StartShooting then return end
    
    if not OldGunStartShooting then
        OldGunStartShooting = item.StartShooting
    end
    
    item.StartShooting = function(Self, ...)
        if not Self.ClientFighter.IsLocalPlayer then
            return OldGunStartShooting(Self, ...)
        end
        
        if config.target.rapidfire then
            Self._shoot_cooldown = 0
        end
        
        local Response = {OldGunStartShooting(Self, ...)}
        local CameraData = Response[3]
        
        if CameraData then
            local Origin1 = Utility:DecodeCFrame(CameraData[utf8.char(0)])
            local Origin2 = Utility:DecodeCFrame(CameraData[utf8.char(1)])
            
            if CameraData[utf8.char(2)] then
                local HitPart = CameraData[utf8.char(2)]
                local Offset = Utility:DecodeCFrame(CameraData[utf8.char(3)])
                
                if config.target.enabled and config.target.character and config.target.autoshoot then
                    local targetPlayer = game:GetService("Players"):GetPlayerFromCharacter(config.target.character)
                    if targetPlayer then
                        local weaponDamage = Self.Info and Self.Info.Damage or 30
                        
                        if not targetDamageTracker[targetPlayer] then
                            targetDamageTracker[targetPlayer] = 0
                        end
                        
                        if targetDamageTracker[targetPlayer] + weaponDamage > 150 then
                            return false
                        end
                        
                        targetDamageTracker[targetPlayer] = targetDamageTracker[targetPlayer] + weaponDamage
                        
                        task.delay(0.1, function()
                            if targetDamageTracker[targetPlayer] then
                                targetDamageTracker[targetPlayer] = 0
                            end
                        end)
                    end
                    
                    local mychar = player.Character
                    if mychar and mychar:FindFirstChild("HumanoidRootPart") then
                        local root = mychar.HumanoidRootPart
                        
                        local head = config.target.character:FindFirstChild(config.target.hitpart) or 
                                    config.target.character:FindFirstChild("Head")
                        
                        if head then
                            local visualpos = config.state.csyncactive and oldpos and oldpos.Position or root.Position
                            local targetpos = predict(head, visualpos)
                            local shootpos = config.state.csyncactive and config.orbit.serverpos or root.Position
                            
                            local params = RaycastParams.new()
                            params.FilterDescendantsInstances = {mychar, config.target.character}
                            params.FilterType = Enum.RaycastFilterType.Exclude
                            
                            local direct = workspace:Raycast(shootpos, targetpos - shootpos, params)
                            
                            if direct then
                                local offsets = {
                                    Vector3.new(0, 12, 0), Vector3.new(0, 16, 0), Vector3.new(0, 20, 0),
                                    Vector3.new(0, 24, 0), Vector3.new(0, 28, 0), Vector3.new(0, 32, 0),
                                    Vector3.new(0, 36, 0), Vector3.new(0, 40, 0),
                                }
                                
                                for i, v in pairs(offsets) do
                                    local scanpos = shootpos + v
                                    if not workspace:Raycast(scanpos, targetpos - scanpos, params) then
                                        shootpos = scanpos
                                        break
                                    end
                                end
                            end
                            
                            HitPart = head
                            Offset = CFrame.new(0.43, 0.25, 0.42)
                            Origin1 = CFrame.new(shootpos, targetpos)
                            Origin2 = CFrame.new(shootpos, targetpos)
                        end
                    end
                end
                
                CameraData[utf8.char(2)] = HitPart
                CameraData[utf8.char(3)] = Utility:EncodeCFrame(Offset)
            end
            
            CameraData[utf8.char(0)] = Utility:EncodeCFrame(Origin1)
            CameraData[utf8.char(1)] = Utility:EncodeCFrame(Origin2)
        end
        
        return unpack(Response)
    end
    
    if not OldGetMouseLocation and modules.fighter.LocalFighter.GetMouseLocation then
        OldGetMouseLocation = modules.fighter.LocalFighter.GetMouseLocation
    end
    
    modules.fighter.LocalFighter.GetMouseLocation = function(...)
        local CallerName = debug.info(3, "n")
        local CallerSource = debug.info(3, "s")
        
        if CallerSource:find("Gun") then
            if config.target.enabled and config.target.autoshoot and config.target.character then
                local head = config.target.character:FindFirstChild(config.target.hitpart) or 
                            config.target.character:FindFirstChild("Head")
                
                if head then
                    local mychar = player.Character
                    if mychar and mychar:FindFirstChild("HumanoidRootPart") then
                        local root = mychar.HumanoidRootPart
                        local visualpos = config.state.csyncactive and oldpos and oldpos.Position or root.Position
                        local targetpos = predict(head, visualpos)
                        
                        local ScreenPosition = Camera:WorldToScreenPoint(targetpos)
                        return Vector2.new(ScreenPosition.X, ScreenPosition.Y)
                    end
                end
            end
        end
        
        return OldGetMouseLocation(...)
    end
end

local function autoshoot()
    if not config.target.enabled or not config.target.character or not config.target.autoshoot then 
        return 
    end
    
    if config.state.reloading or config.state.outofammo then
        return
    end
    
    if not canuse() then
        return
    end
    
    local mychar = player.Character
    if not mychar or not mychar:FindFirstChild("HumanoidRootPart") then return end
    
    if not modules.fighter or not modules.fighter.LocalFighter then return end
    
    local item = modules.fighter.LocalFighter.EquippedItem
    if not item then return end
    
    hookGunMethods()
    
    local head = config.target.character:FindFirstChild(config.target.hitpart) or 
                config.target.character:FindFirstChild("Head")
    if not head then return end
    
    pcall(function()
        modules.fighter.LocalFighter:Shoot()
    end)
end

local Players = game:GetService("Players")

Players.PlayerRemoving:Connect(function(targetPlayer)
    targetDamageTracker[targetPlayer] = nil
end)

for _, targetPlayer in pairs(Players:GetPlayers()) do
    if targetPlayer.Character then
        local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                targetDamageTracker[targetPlayer] = nil
            end)
        end
    end
    
    targetPlayer.CharacterAdded:Connect(function(char)
        targetDamageTracker[targetPlayer] = nil
    end)
end

local function checkhit()
    if not config.target.enabled or not config.target.character then return end
    
    local char = config.target.character
    if not char or not char.Parent then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local targetplayer = players:GetPlayerFromCharacter(char)
    if not targetplayer then return end
    
    local last = trackhealth[targetplayer] or humanoid.Health
    
    if humanoid.Health < last then
        -- NEW: Update damage time tracker
        last_damage_time[targetplayer] = tick()
        
        local mychar = player.Character
        if mychar and mychar:FindFirstChild("HumanoidRootPart") then
            local targetroot = char:FindFirstChild("HumanoidRootPart")
            if targetroot then
                local mypos = config.state.csyncactive and oldpos and oldpos.Position or mychar.HumanoidRootPart.Position
                local dist = (mypos - targetroot.Position).Magnitude
                
                if dist <= 2000 then
                    if hitTracerEnabled then
                        local tracerstart = camera.CFrame.Position + (camera.CFrame.LookVector * 2)
                        createBulletTracer(tracerstart, targetroot.Position, true)
                    end
                    
                    if hitSoundEnabled then
                        task.spawn(function()
                            local soundid = soundAssets[hitSoundStyle]
                            if soundid then
                                local sound = Instance.new("Sound")
                                sound.SoundId = soundid
                                sound.Volume = hitSoundVolume
                                sound.Pitch = hitSoundPitch
                                sound.Parent = workspace
                                sound:Play()
                                game:GetService("Debris"):AddItem(sound, 2)
                            end
                        end)
                    end
                end
            end
        end
    end
    
    trackhealth[targetplayer] = humanoid.Health
end

local function togglekey()
    if config.target.auto then return end
    
    if config.target.enabled and config.target.character then
        config.target.enabled = false
        stopsync()
        config.target.character = nil
        config.target.lastchar = nil
        config.target.lastplayer = nil
        config.target.manualkey = false
        config.prediction.velbuffer = {}
        config.prediction.posbuffer = {}
        Utility.Raycast = silentAimEnabled and silentAimRaycast or OriginalRaycast
        
        -- Activate voidhide if no ammo
        if config.voidhide.enabled then
            local current, max, melee = getammo()
            if current <= 0 and not melee then
                if not config.voidhide.active then
                    local char = player.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        config.voidhide.originalPosition = char.HumanoidRootPart.Position
                        config.voidhide.active = true
                        
                        -- Start teleport loop
                        if config.voidhide.connection then
                            config.voidhide.connection:Disconnect()
                        end
                        
                        config.voidhide.connection = run_service.Heartbeat:Connect(function()
                            if not config.voidhide.active then return end
                            
                            local char = player.Character
                            if char and char:FindFirstChild("HumanoidRootPart") then
                                local randomAngle = math.random() * math.pi * 2
                                local randomDistance = math.random(500, 5000)
                                
                                local currentPos = char.HumanoidRootPart.Position
                                local newX = currentPos.X + math.cos(randomAngle) * randomDistance
                                local newZ = currentPos.Z + math.sin(randomAngle) * randomDistance
                                local newY = currentPos.Y + math.random(50, 200)
                                
                                local newPos = Vector3.new(newX, newY, newZ)
                                char.HumanoidRootPart.CFrame = CFrame.new(newPos)
                                
                                pcall(function()
                                    replicated_storage.Remotes.Replication.Fighter.Move:FireServer(
                                        newPos,
                                        tick()
                                    )
                                end)
                            end
                        end)
                    end
                end
            end
        end
    else
        local target = nearest()
        if target and canuse() then
            config.target.enabled = true
            config.target.character = target
            config.target.lastchar = target
            config.target.lastplayer = players:GetPlayerFromCharacter(target)
            config.target.manualkey = true
            config.prediction.velbuffer = {}
            config.prediction.posbuffer = {}
            startsync()
            Utility.Raycast = raymod
            
            -- Deactivate voidhide if active
            if config.voidhide.active then
                if config.voidhide.connection then
                    config.voidhide.connection:Disconnect()
                    config.voidhide.connection = nil
                end
                config.voidhide.active = false
                config.voidhide.originalPosition = nil
            end
        else
            config.target.enabled = false
            config.target.manualkey = false
            
            -- Activate voidhide if no target and no ammo
            if config.voidhide.enabled then
                local current, max, melee = getammo()
                if current <= 0 and not melee then
                    if not config.voidhide.active then
                        local char = player.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            config.voidhide.originalPosition = char.HumanoidRootPart.Position
                            config.voidhide.active = true
                            
                            -- Start teleport loop
                            if config.voidhide.connection then
                                config.voidhide.connection:Disconnect()
                            end
                            
                            config.voidhide.connection = run_service.Heartbeat:Connect(function()
                                if not config.voidhide.active then return end
                                
                                local char = player.Character
                                if char and char:FindFirstChild("HumanoidRootPart") then
                                    local randomAngle = math.random() * math.pi * 2
                                    local randomDistance = math.random(500, 5000)
                                    
                                    local currentPos = char.HumanoidRootPart.Position
                                    local newX = currentPos.X + math.cos(randomAngle) * randomDistance
                                    local newZ = currentPos.Z + math.sin(randomAngle) * randomDistance
                                    local newY = currentPos.Y + math.random(50, 200)
                                    
                                    local newPos = Vector3.new(newX, newY, newZ)
                                    char.HumanoidRootPart.CFrame = CFrame.new(newPos)
                                    
                                    pcall(function()
                                        replicated_storage.Remotes.Replication.Fighter.Move:FireServer(
                                            newPos,
                                            tick()
                                        )
                                    end)
                                end
                            end)
                        end
                    end
                end
            end
        end
    end
end

local function reload()
    local current, max, melee = getammo()
    
    if current <= 0 and not melee and not config.state.reloading then
        config.state.outofammo = true
        config.state.reloading = true
        
        -- Activate voidhide if enabled
        if config.voidhide.enabled and not config.voidhide.active then
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                config.voidhide.originalPosition = char.HumanoidRootPart.Position
                config.voidhide.active = true
                
                -- Store csync state and stop it
                local wasCsyncActive = config.state.csyncactive
                if wasCsyncActive then
                    stopsync()
                end
                
                -- Start continuous teleport loop to actually hide you
                if config.voidhide.connection then
                    config.voidhide.connection:Disconnect()
                end
                
                config.voidhide.connection = run_service.Heartbeat:Connect(function()
                    if not config.voidhide.active then return end
                    
                    local char = player.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        -- Generate random position far away (like in your example code)
                        local randomAngle = math.random() * math.pi * 2
                        local randomDistance = math.random(500, 5000) -- 500 to 5000 studs
                        
                        local currentPos = char.HumanoidRootPart.Position
                        local newX = currentPos.X + math.cos(randomAngle) * randomDistance
                        local newZ = currentPos.Z + math.sin(randomAngle) * randomDistance
                        local newY = currentPos.Y + math.random(50, 200) -- Add some height
                        
                        local newPos = Vector3.new(newX, newY, newZ)
                        
                        -- Teleport to new position
                        char.HumanoidRootPart.CFrame = CFrame.new(newPos)
                        
                        -- Make it sync with server by firing the remote
                        pcall(function()
                            -- Try different remote methods
                            replicated_storage.Remotes.Replication.Fighter.Move:FireServer(
                                newPos,
                                tick()
                            )
                        end)
                    end
                end)
                
                -- Restore csync if it was active (but voidhide takes priority)
                if wasCsyncActive and config.target.enabled and config.target.character then
                    -- Don't restore csync while voidhiding
                end
            end
        end
        
        task.spawn(function()
            local maxwait = 10
            local start = tick()
            
            while tick() - start < maxwait do
                task.wait(0.1)
                local newammo, newmax, newmelee = getammo()
                
                if newammo > 0 or newmelee then
                    config.state.outofammo = false
                    config.state.reloading = false
                    config.orbs.collecting = false
                    config.orbs.currentOrb = nil
                    
                    -- Deactivate voidhide if active
                    if config.voidhide.active then
                        if config.voidhide.connection then
                            config.voidhide.connection:Disconnect()
                            config.voidhide.connection = nil
                        end
                        
                        local char = player.Character
                        if char and char:FindFirstChild("HumanoidRootPart") and config.voidhide.originalPosition then
                            local safePosition = config.voidhide.originalPosition + Vector3.new(0, 5, 0)
                            char.HumanoidRootPart.CFrame = CFrame.new(safePosition)
                            
                            -- Sync with server
                            pcall(function()
                                replicated_storage.Remotes.Replication.Fighter.Move:FireServer(
                                    safePosition,
                                    tick()
                                )
                            end)
                            
                            config.voidhide.active = false
                            config.voidhide.originalPosition = nil
                        end
                    end
                    
                    -- Re-establish normal orbit after reload
                    if config.target.enabled and config.target.character and valid(config.target.character) then
                        if not config.state.csyncactive then
                            startsync()
                        end
                    end
                    
                    return
                end
            end
            
            config.state.reloading = false
            config.state.outofammo = false
            config.orbs.collecting = false
            config.orbs.currentOrb = nil
            
            -- Deactivate voidhide on timeout
            if config.voidhide.active then
                if config.voidhide.connection then
                    config.voidhide.connection:Disconnect()
                    config.voidhide.connection = nil
                end
                config.voidhide.active = false
                config.voidhide.originalPosition = nil
            end
        end)
        
        return false
    end
    
    if current > 0 then
        config.state.outofammo = false
        config.state.reloading = false
    end
    
    return true
end


run_service.RenderStepped:Connect(function()
    drawind()
    
    if config.target.enabled and config.target.character and config.prediction.enabled then
        updatevel()
    end
    
    -- NEW: Basic orb collection (always active when auto target is on)
    collectOrbsBasic()
end)

run_service.Heartbeat:Connect(function()
    if config.target.auto and not config.target.manualkey then
        if not canuse() then
            reload()
            return
        end
        
        local current, max, melee = getammo()
        local hasammo = current > 0 or melee
        
        -- Handle voidhide for auto target when no target found
        if config.voidhide.enabled and config.target.auto and not config.target.character then
            if not config.voidhide.active then
                local char = player.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    config.voidhide.originalPosition = char.HumanoidRootPart.Position
                    config.voidhide.active = true
                    
                    -- Stop csync first
                    if config.state.csyncactive then
                        stopsync()
                    end
                    
                    -- Start teleport loop
                    if config.voidhide.connection then
                        config.voidhide.connection:Disconnect()
                    end
                    
                    config.voidhide.connection = run_service.Heartbeat:Connect(function()
                        if not config.voidhide.active then return end
                        
                        local char = player.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            -- Generate random position far away
                            local randomAngle = math.random() * math.pi * 2
                            local randomDistance = math.random(500, 5000)
                            
                            local currentPos = char.HumanoidRootPart.Position
                            local newX = currentPos.X + math.cos(randomAngle) * randomDistance
                            local newZ = currentPos.Z + math.sin(randomAngle) * randomDistance
                            local newY = currentPos.Y + math.random(50, 200)
                            
                            local newPos = Vector3.new(newX, newY, newZ)
                            char.HumanoidRootPart.CFrame = CFrame.new(newPos)
                            
                            -- Sync with server
                            pcall(function()
                                replicated_storage.Remotes.Replication.Fighter.Move:FireServer(
                                    newPos,
                                    tick()
                                )
                            end)
                        end
                    end)
                end
            end
            return -- Don't continue searching for targets while voidhiding
        end
        
        if hasammo and not config.state.reloading then
            if not config.target.enabled or (config.state.outofammo and config.target.lastchar and 
               valid(config.target.lastchar)) then
                local newtarget = config.target.lastchar
                
                if not newtarget or not valid(newtarget) then
                    newtarget = nearest()
                end
                
                if newtarget and newtarget ~= config.target.character then
                    if config.target.enabled then
                        stopsync()
                    end
                    
                    config.target.enabled = true
                    config.target.character = newtarget
                    config.target.lastchar = newtarget
                    config.target.lastplayer = players:GetPlayerFromCharacter(newtarget)
                    config.state.outofammo = false
                    config.prediction.velbuffer = {}
                    config.prediction.posbuffer = {}
                    
                    startsync()
                    Utility.Raycast = raymod
                    
                    -- Deactivate voidhide when getting target
                    if config.voidhide.active then
                        if config.voidhide.connection then
                            config.voidhide.connection:Disconnect()
                            config.voidhide.connection = nil
                        end
                        config.voidhide.active = false
                        config.voidhide.originalPosition = nil
                    end
                end
            elseif config.target.enabled and not valid(config.target.character) then
                config.target.enabled = false
                stopsync()
                config.target.character = nil
                config.prediction.velbuffer = {}
                config.prediction.posbuffer = {}
                Utility.Raycast = silentAimEnabled and silentAimRaycast or OriginalRaycast
                
                -- Activate voidhide if no target found (for auto mode)
                if config.voidhide.enabled and config.target.auto then
                    if not config.voidhide.active then
                        local char = player.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            config.voidhide.originalPosition = char.HumanoidRootPart.Position
                            config.voidhide.active = true
                            
                            -- Start teleport loop
                            if config.voidhide.connection then
                                config.voidhide.connection:Disconnect()
                            end
                            
                            config.voidhide.connection = run_service.Heartbeat:Connect(function()
                                if not config.voidhide.active then return end
                                
                                local char = player.Character
                                if char and char:FindFirstChild("HumanoidRootPart") then
                                    -- Generate random position
                                    local randomAngle = math.random() * math.pi * 2
                                    local randomDistance = math.random(500, 5000)
                                    
                                    local currentPos = char.HumanoidRootPart.Position
                                    local newX = currentPos.X + math.cos(randomAngle) * randomDistance
                                    local newZ = currentPos.Z + math.sin(randomAngle) * randomDistance
                                    local newY = currentPos.Y + math.random(50, 200)
                                    
                                    local newPos = Vector3.new(newX, newY, newZ)
                                    char.HumanoidRootPart.CFrame = CFrame.new(newPos)
                                    
                                    pcall(function()
                                        replicated_storage.Remotes.Replication.Fighter.Move:FireServer(
                                            newPos,
                                            tick()
                                        )
                                    end)
                                end
                            end)
                        end
                    end
                end
                return
            end
        else
            reload()
        end
    end
    
    if config.target.enabled and config.target.character then
        if not valid(config.target.character) then
            config.target.enabled = false
            stopsync()
            config.target.character = nil
            config.target.lastchar = nil
            config.target.lastplayer = nil
            config.target.manualkey = false
            config.prediction.velbuffer = {}
            config.prediction.posbuffer = {}
            Utility.Raycast = silentAimEnabled and silentAimRaycast or OriginalRaycast
            return
        end
        
        if not reload() then
            return
        end
        
        if config.target.autoshoot then
            autoshoot()
        end
        
        checkhit()
    end
end)

local targetgroup = Tabs.Rage:AddRightTabbox()

local ragebottab = targetgroup:AddTab('ragebot')

local ragebotvisualtab = targetgroup:AddTab('visualizer')

local togglemain = ragebottab:AddToggle("TargetOn", {
    Text = "enable",
    Default = false,
    Callback = function(val)
        if config.target.auto then return end
        
        if val then
            local target = nearest()
            if target and canuse() then
                local current, max, melee = getammo()
                local hasammo = current > 0 or melee
                
                if hasammo then
                    config.target.enabled = true
                    config.target.character = target
                    config.target.lastchar = target
                    config.target.lastplayer = players:GetPlayerFromCharacter(target)
                    config.target.manualkey = true
                    config.prediction.velbuffer = {}
                    config.prediction.posbuffer = {}
                    startsync()
                    Utility.Raycast = raymod
                else
                    config.target.enabled = false
                end
            else
                config.target.enabled = false
            end
        else
            config.target.enabled = false
            stopsync()
            config.target.character = nil
            config.target.lastchar = nil
            config.target.lastplayer = nil
            config.target.manualkey = false
            config.prediction.velbuffer = {}
            config.prediction.posbuffer = {}
            Utility.Raycast = silentAimEnabled and silentAimRaycast or OriginalRaycast
        end
    end
}):AddKeyPicker("TargetKey", {
    Text = "Ragebot",
    Default = "None",
    Mode = "Toggle",
    Callback = function(state)
        togglekey()
    end
})

ragebottab:AddToggle("AutoTarget", {
    Text = "auto target",
    Default = false,
    Callback = function(val)
        config.target.auto = val
        if not val and config.target.enabled then
            config.target.enabled = false
            stopsync()
            config.target.character = nil
            config.target.lastchar = nil
            config.target.lastplayer = nil
            config.target.manualkey = false
            config.prediction.velbuffer = {}
            config.prediction.posbuffer = {}
            Utility.Raycast = silentAimEnabled and silentAimRaycast or OriginalRaycast
        end
    end
})

local voidhideToggle = ragebottab:AddToggle("Voidhide", {
    Text = "voidhide",
    Tooltip = "Voidhide",
    Default = false,
    Callback = function(val)
        config.voidhide.enabled = val
        
        if not val and config.voidhide.active then
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") and config.voidhide.originalPosition then
                local safePosition = config.voidhide.originalPosition + Vector3.new(0, 5, 0)
                char.HumanoidRootPart.CFrame = CFrame.new(safePosition)
                config.voidhide.active = false
                config.voidhide.originalPosition = nil
            end
        end
    end
})


ragebottab:AddDropdown("TargetPart", {
    Text = "hit part",
    Default = "Head",
    Risky = true,
    Values = {"Head", "HumanoidRootPart", "Torso", "UpperTorso", "Closest", "Random"},
    Callback = function(val)
        config.target.hitpart = val
    end
})

ragebottab:AddToggle("AutoShootT", {
    Text = "manipulation",
    Tooltip = "Bullet Manipulation (Auto Shoot)",
    Default = false,
    Risky = true,
    Callback = function(val)
        config.target.autoshoot = val
    end
})

ragebottab:AddToggle("PredictT", {
    Text = "prediction",
    Default = false,
    Callback = function(val)
        config.prediction.enabled = val
        if not val then
            config.prediction.velocity = Vector3.new(0, 0, 0)
            config.prediction.acceleration = Vector3.new(0, 0, 0)
            config.prediction.lastposition = nil
            config.prediction.velbuffer = {}
            config.prediction.posbuffer = {}
        end
    end
})

ragebottab:AddSlider("PredictMul", {
    Text = "prediction mult",
    Default = 1.2,
    Min = 0.1,
    Max = 3.0,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        config.prediction.multiplier = val
    end
})

ragebotvisualtab:AddToggle("VisEnabled", {
    Text = "enable",
    Default = false,
    Callback = function(val)
        config.visualizer.enabled = val
    end
})

-- Tracer settings
ragebotvisualtab:AddToggle("VisTracerEnabled", {
    Text = "tracer",
    Default = false,
    Callback = function(val)
        config.visualizer.tracer.enabled = val
    end
}):AddColorPicker("VisTracerColor", {
    Default = config.visualizer.tracer.color,
    Title = "tracer color",
    Callback = function(val)
        config.visualizer.tracer.color = val
    end
})

ragebotvisualtab:AddDropdown("VisTracerStart", {
    Text = "tracer start",
    Default = "cursor",
    Values = {"cursor", "muzzle"},
    Callback = function(val)
        config.visualizer.tracer.start_point = val
    end
})

ragebotvisualtab:AddToggle("VisTracerOutline", {
    Text = "tracer outline",
    Default = true,
    Callback = function(val)
        config.visualizer.tracer.outline = val
    end
}):AddColorPicker("VisTracerOutlineColor", {
    Default = config.visualizer.tracer.outline_color,
    Title = "outline color",
    Callback = function(val)
        config.visualizer.tracer.outline_color = val
    end
})

ragebotvisualtab:AddSlider("VisTracerThickness", {
    Text = "tracer thickness",
    Default = 1,
    Min = 0.1,
    Max = 3,
    Rounding = 1,
    Compact = true,
    Callback = function(val)
        config.visualizer.tracer.thickness = val
        config.visualizer.tracer.outline_thickness = val * 0.8
    end
})

-- Indicator settings
ragebotvisualtab:AddToggle("VisIndicatorEnabled", {
    Text = "indicator",
    Default = false,
    Callback = function(val)
        config.visualizer.indicator.enabled = val
    end
}):AddColorPicker("VisIndicatorColor", {
    Default = config.visualizer.indicator.color,
    Title = "text color",
    Callback = function(val)
        config.visualizer.indicator.color = val
    end
}):AddColorPicker("VisIndicatorAccent", {
    Default = config.visualizer.indicator.accent_color,
    Title = "accent color",
    Callback = function(val)
        config.visualizer.indicator.accent_color = val
    end
})

ragebotvisualtab:AddDropdown("VisIndOptions", {
    Text = "display",
    Default = {"name", "position", "hit reg"},
    Values = {"name", "position", "hit reg"},
    Multi = true,
    Callback = function(val)
        config.visualizer.indicator.display_options = val
    end
})

game:GetService("ScriptContext").DescendantRemoving:Connect(function(descendant)
    if descendant == script then
        if targetOn then
            Utility.Raycast = OriginalRaycast
        end
        tInd:Remove()
    end
end)

player.CharacterRemoving:Connect(function()
    if config.voidhide.active then
        config.voidhide.active = false
        config.voidhide.originalPosition = nil
    end
    
    if config.target.enabled then
        stopsync()
        Utility.Raycast = OriginalRaycast
        task.wait(0.5)
        if config.target.enabled and config.target.character then
            task.defer(function()
                startsync()
            end)
            Utility.Raycast = raymod
        end
    end
end)
end

local v2 = Tabs.Misc:AddLeftGroupbox('movement')
    local UIS = game:GetService("UserInputService")
    local RS = game:GetService("RunService")
    local LP = game:GetService("Players").LocalPlayer
    local lastrecord
    _G.wenabled = false
    _G.keytooenabled = false
    _G.wvalue = 16
    _G.wkey = nil
    _G.cframeactive = false
    _G.keyheldcframe = false
    _G.cframevalue = 16
    _G.cframekey = nil
    
    _G.cframeflyactive = false
    _G.keyheldcframefly = false
    _G.cframeflyvalue = 100
    local flyVelocity = Vector3.new()

    local function toggleVar(var)
        _G[var] = not _G[var]
    end

    v2:AddToggle("cframespf_enabled", {
        Text = "CFrame Walkspeed",
        Default = false,
        Callback = function(state)
            _G.cframeactive = state
        end
    }):AddKeyPicker("cframespf_key", {
        Default = "",
        NoUI = false,
        Mode = 'Toggle',
        Text = "CFrame Walkspeed",
        Callback = function(state)
            toggleVar("keyheldcframe")
        end,
        ChangedCallback = function(newKey)
            _G.cframekey = newKey
        end
    })

    v2:AddSlider("spdd_value", {
        Text = "CFrame Walkspeed Speed",
        Default = 30,
        Min = 16,
        Max = 750,
        Rounding = 0,
        Compact = true,
        Callback = function(value)
            _G.cframevalue = value
        end
    })

    RS.Heartbeat:Connect(function(dt)
        if _G.cframeactive and _G.keyheldcframe then
            local char = LP.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if hrp and hum then
                local moveDir = hum.MoveDirection
                if moveDir.Magnitude > 0 then
                    hrp.CFrame += moveDir * (dt * _G.cframevalue * 1.5)
                    hrp.Velocity = Vector3.new(0, hrp.Velocity.Y, 0)
                end
            end
        end
    end)

    RS.Heartbeat:Connect(function(dt)
        if _G.cframeflyactive and _G.keyheldcframefly then
            local char = LP.Character
            if not char then return end

            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hrp or not hum then return end
            
            local look = workspace.CurrentCamera.CFrame.LookVector
            local right = workspace.CurrentCamera.CFrame.RightVector
            local move = Vector3.new()
            
            if UIS:IsKeyDown(Enum.KeyCode.W) then move += look end
            if UIS:IsKeyDown(Enum.KeyCode.S) then move -= look end
            if UIS:IsKeyDown(Enum.KeyCode.A) then move -= right end
            if UIS:IsKeyDown(Enum.KeyCode.D) then move += right end
            if UIS:IsKeyDown(Enum.KeyCode.Space) then move += Vector3.new(0, 1, 0) end
            if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then move -= Vector3.new(0, 1, 0) end
            
            if move.Magnitude > 0 then
                move = move.Unit
            end
            
            local targetVelocity = move * _G.cframeflyvalue
            flyVelocity = flyVelocity:Lerp(targetVelocity, dt * 8)
            
            hrp.CFrame = hrp.CFrame + (flyVelocity * dt)
            hrp.Velocity = Vector3.new(0, 0, 0)
            
            hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + workspace.CurrentCamera.CFrame.LookVector * Vector3.new(1, 0, 1))
        end
    end)

    v2:AddToggle("cframefly_enabled", {
        Text = "CFrame Fly",
        Default = false,
        Callback = function(state)
            _G.cframeflyactive = state
            if not state then
                flyVelocity = Vector3.new()
            end
        end
    }):AddKeyPicker("cframefly_key", {
        Default = "None",
        Mode = "Toggle",
        Text = "CFrame Fly",
        Callback = function(state)
            _G.keyheldcframefly = state
            if not state then
                flyVelocity = Vector3.new()
            end
        end
    })

    v2:AddSlider("cframefly_speed", {
        Text = "CFrame Fly Speed",
        Default = 50,
        Min = 16,
        Max = 750,
        Rounding = 0,
        Compact = true,
        Callback = function(value)
            _G.cframeflyvalue = value
        end
    })

v3 = Tabs.Misc:AddLeftGroupbox('auto ban - ranked')

weapons = {
    "Assault Rifle",
    "Sniper",
    "Bow",
    "Burst Rifle",
    "Crossbow",
    "Gunblade",
    "RPG",
    "Shotgun",
    "Energy Rifle",
    "Flamethrower",
    "Grenade Launcher",
    "Minigun",
    "Paintball Gun",
    "Distortion",
    "Permafrost",
    "Handgun",
    "Daggers",
    "Flare Gun",
    "Revolver",
    "Shorty",
    "Spray",
    "Uzi",
    "Energy Pistols",
    "Exogun",
    "Slingshot",
    "Warper",
    "Fists",
    "Battle Axe",
    "Chainsaw",
    "Katana",
    "Knife",
    "Riot Shield",
    "Scythe",
    "Maul",
    "Trowel",
    "Grenade",
    "Flashbang",
    "Freeze Ray",
    "Jump Pad",
    "Molotov",
    "Satchel",
    "Smoke Grenade",
    "War Horn",
    "Medkit",
    "Substapce Tripmine",
    "Warpstone"
}

enabled = false
weapon1 = "Riot Shield"
weapon2 = "Katana"
thread = nil

storage = game:GetService("ReplicatedStorage")
remote = storage:WaitForChild("Remotes"):WaitForChild("Duels"):WaitForChild("Vote")

stop = function()
    if thread then
        thread = nil
    end
end

start = function()
    stop()
    
    thread = task.spawn(function()
        while enabled and task.wait(1) do
            list = {}
            
            if weapon1 and weapon1 ~= "" then
                table.insert(list, weapon1)
            end
            
            if weapon2 and weapon2 ~= "" then
                table.insert(list, weapon2)
            end
            
            if #list > 0 then
                i = 1
                while enabled do
                    remote:FireServer(list[i])
                    
                    i = i % #list + 1
                    
                    task.wait(1)
                    
                    if not thread then
                        break
                    end
                end
            end
        end
    end)
end

v3:AddToggle("enabled", {
    Text = "enable",
    Default = false,
    Callback = function(s)
        enabled = s
        
        if s then
            start()
        else
            stop()
        end
    end
})

first = v3:AddDropdown("first", {
    Text = "weapon 1",
    Values = weapons,
    Default = 1,
    Multi = false,
    Callback = function(v)
        weapon1 = v
        if enabled then
            stop()
            start()
        end
    end
})

search1 = v3:AddInput("search1", {
    Text = "search weapon 1",
    Placeholder = "",
    ClearTextOnFocus = false,
    Callback = function(t)
        if t == "" then
            first:SetValues(weapons)
            return
        end
        f = {}
        t = t:lower()
        for _, w in ipairs(weapons) do
            if w:lower():find(t, 1, true) then
                table.insert(f, w)
            end
        end
        if #f > 0 then
            first:SetValues(f)
            weapon1 = f[1]
            first:SetValue(weapon1)
            if enabled then
                stop()
                start()
            end
        end
    end
})

second = v3:AddDropdown("second", {
    Text = "weapon 2",
    Values = weapons,
    Default = 2,
    Multi = false,
    Callback = function(v)
        weapon2 = v
        if enabled then
            stop()
            start()
        end
    end
})

search2 = v3:AddInput("search2", {
    Text = "search weapon 2",
    Placeholder = "",
    ClearTextOnFocus = false,
    Callback = function(t)
        if t == "" then
            second:SetValues(weapons)
            return
        end
        f = {}
        t = t:lower()
        for _, w in ipairs(weapons) do
            if w:lower():find(t, 1, true) then
                table.insert(f, w)
            end
        end
        if #f > 0 then
            second:SetValues(f)
            weapon2 = f[1]
            second:SetValue(weapon2)
            if enabled then
                stop()
                start()
            end
        end
    end
})

game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    stop()
    enabled = false
end)

v4 = Tabs.Misc:AddRightGroupbox('auto queue')

queuemode = "1v1"
ranked = false
queueenabled = false
queuethread = nil

queuestop = function()
    if queuethread then
        queuethread = nil
    end
end

queuestart = function()
    queuestop()
    
    queuethread = task.spawn(function()
        while queueenabled and task.wait(1) do
            local success, result = pcall(function()
                local storage = game:GetService("ReplicatedStorage")
                local remotes = storage:WaitForChild("Remotes")
                local matchmaking = remotes:WaitForChild("Matchmaking")
                local joinqueue = matchmaking:WaitForChild("JoinQueue")
                
                if ranked then
                    return joinqueue:InvokeServer(queuemode, true)
                else
                    return joinqueue:InvokeServer(queuemode)
                end
            end)
            
            if not success and not string.find(result:lower(), "already in queue") then
                queuethread = nil
                break
            end
        end
    end)
end

v4:AddToggle("queueenabled", {
    Text = "enable",
    Default = false,
    Callback = function(s)
        queueenabled = s
        
        if s then
            queuestart()
        else
            queuestop()
        end
    end
})

v4:AddDropdown("queuemode", {
    Text = "queue mode",
    Values = {"1v1", "2v2", "3v3", "4v4", "5v5"},
    Default = 1,
    Multi = false,
    Callback = function(v)
        queuemode = v
        if queueenabled then
            queuestop()
            queuestart()
        end
    end
})

v4:AddToggle("ranked", {
    Text = "ranked",
    Default = false,
    Callback = function(s)
        ranked = s
        if queueenabled then
            queuestop()
            queuestart()
        end
    end
})

game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    queuestop()
    queueenabled = false
end)

local v555 = Tabs.Misc:AddRightGroupbox('miscellaneous')
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

_G.Features = _G.Features or {}
_G.Features.Noclip = _G.Features.Noclip or {
    Enabled = false,
    Conn = nil
}


_G.Features.ModDetector = _G.Features.ModDetector or {
    Enabled = true,
    Connection = nil,
    Checking = false
}

local function updateNoclip()
    if _G.Features.Noclip.Conn then
        _G.Features.Noclip.Conn:Disconnect()
        _G.Features.Noclip.Conn = nil
    end
    local character = LocalPlayer.Character
    if not character then return end
    if _G.Features.Noclip.Enabled then
        _G.Features.Noclip.Conn = RunService.Stepped:Connect(function()
            local currentChar = LocalPlayer.Character
            if not currentChar then return end
            for _, part in pairs(currentChar:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    else
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.2)
    if _G.Features.Noclip.Enabled then
        updateNoclip()
    end
end)


v555:AddToggle('noclip', {
    Text = 'noclip',
    Default = _G.Features.Noclip.Enabled,
    Callback = function(Value)
        _G.Features.Noclip.Enabled = Value
        updateNoclip()
    end
})

local function stopModDetector()
    if _G.Features.ModDetector.Connection then
        _G.Features.ModDetector.Connection:Disconnect()
        _G.Features.ModDetector.Connection = nil
    end
    _G.Features.ModDetector.Checking = false
end

local function startModDetector()
    if not _G.Features.ModDetector.Enabled then return end
    if _G.Features.ModDetector.Checking then return end
    if game.GameId ~= 6035872082 then return end
    
    _G.Features.ModDetector.Checking = true
    
    task.spawn(function()
        repeat task.wait() until game:IsLoaded()
        
        if game.CreatorType ~= Enum.CreatorType.Group then
            _G.Features.ModDetector.Checking = false
            return
        end
        
        local HttpService = game:GetService("HttpService")
        local groupId = game.CreatorId
        
        local function kickPlayer()
            LocalPlayer:Kick("Mod Detected!")
            task.wait(0.5)
            if LocalPlayer.Parent then
                game:Shutdown()
            end
        end
        
        local function isStaffRole(roleName)
            if not roleName or typeof(roleName) ~= "string" then return false end
            local lower = string.lower(roleName)
            return string.find(lower, "mod") or 
                   string.find(lower, "staff") or 
                   string.find(lower, "contributor") or 
                   string.find(lower, "script") or 
                   string.find(lower, "build") or
                   string.find(lower, "admin") or
                   string.find(lower, "owner")
        end
        
        local function checkPlayer(player)
            if player == LocalPlayer then return false end
            
            local success, role = pcall(function()
                return player:GetRoleInGroup(groupId)
            end)
            
            if success and role and isStaffRole(role) then
                return true
            end
            return false
        end
        
        local function checkAllPlayers()
            for _, player in ipairs(Players:GetPlayers()) do
                if checkPlayer(player) then
                    return true
                end
            end
            return false
        end
        
        
        if checkAllPlayers() then
            kickPlayer()
            _G.Features.ModDetector.Checking = false
            return
        end
        
        
        _G.Features.ModDetector.Connection = Players.PlayerAdded:Connect(function(player)
            if not _G.Features.ModDetector.Enabled then return end
            task.wait(1)
            if checkPlayer(player) then
                kickPlayer()
            end
        end)
        
        
        while _G.Features.ModDetector.Enabled and task.wait(15) do
            if not _G.Features.ModDetector.Enabled then break end
            if checkAllPlayers() then
                kickPlayer()
                break
            end
        end
        
        _G.Features.ModDetector.Checking = false
    end)
end

local function updateModDetector()
    if _G.Features.ModDetector.Enabled then
        startModDetector()
    else
        stopModDetector()
    end
end


v555:AddToggle('moddetector', {
    Text = 'mod detector',
    Default = _G.Features.ModDetector.Enabled,
    Callback = function(Value)
        _G.Features.ModDetector.Enabled = Value
        updateModDetector()
    end
})

if _G.Features.ModDetector.Enabled then
    startModDetector()
end

local deviceBox = Tabs.Misc:AddRightGroupbox('device spoof')

_G.Features.DeviceSpoof = _G.Features.DeviceSpoof or {
    Enabled = false,
    CurrentDevice = "Console",
    LastApplied = 0
}

_G.Features.SlideBoost = _G.Features.SlideBoost or {
    Enabled = false,
    Speed = 300
}

local deviceConfigs = {
    ["Mobile"] = {
        Display = "Mobile",
        Code = "Touch"
    },
    ["Console"] = {
        Display = "Console",
        Code = "Gamepad"
    },
    ["VR"] = {
        Display = "VR",
        Code = "VR"
    },
    ["PC"] = {
        Display = "PC",
        Code = "MouseKeyboard"
    }
}

local function detectRealDevice()
    local inputType = UserInputService:GetLastInputType()
    if inputType == Enum.UserInputType.Touch then
        return "Mobile"
    elseif inputType == Enum.UserInputType.Gamepad1 then
        return "Console"
    elseif inputType == Enum.UserInputType.VR then
        return "VR"
    else
        return "PC"
    end
end

local function applyDeviceSpoof()
    if not _G.Features.DeviceSpoof.Enabled then 
        return 
    end
    
    local device = _G.Features.DeviceSpoof.CurrentDevice
    local deviceConfig = deviceConfigs[device]
    
    if not deviceConfig then return end
    
    local currentTime = tick()
    
    if currentTime - _G.Features.DeviceSpoof.LastApplied < 0.5 then
        return
    end
    
    _G.Features.DeviceSpoof.LastApplied = currentTime
    
    for attempt = 1, 3 do
        local success = pcall(function()
            local remotes = game:GetService("ReplicatedStorage")
            if remotes:FindFirstChild("Remotes") then
                remotes = remotes.Remotes
                if remotes:FindFirstChild("Replication") then
                    remotes = remotes.Replication
                    if remotes:FindFirstChild("Fighter") then
                        remotes = remotes.Fighter
                        if remotes:FindFirstChild("SetControls") then
                            remotes.SetControls:FireServer(deviceConfig.Code)
                            return true
                        end
                    end
                end
            end
            return false
        end)
        
        if success then
            break
        else
            task.wait(0.2)
        end
    end
end

local function checkAndReapplyDeviceSpoof()
    if not _G.Features.DeviceSpoof.Enabled then return end
    local currentTime = tick()
    if currentTime - _G.Features.DeviceSpoof.LastApplied > 30 then
        applyDeviceSpoof()
    end
end

deviceBox:AddToggle('device_spoof', {
    Text = 'enable',
    Default = _G.Features.DeviceSpoof.Enabled,
    Callback = function(Value)
        _G.Features.DeviceSpoof.Enabled = Value
        if Value then
            applyDeviceSpoof()
        end
    end
})

deviceBox:AddDropdown('device_type', {
    Text = 'Device Type',
    Default = _G.Features.DeviceSpoof.CurrentDevice,
    Values = {"Mobile", "Console", "VR", "PC"},
    Callback = function(Value)
        _G.Features.DeviceSpoof.CurrentDevice = Value
        if _G.Features.DeviceSpoof.Enabled then
            applyDeviceSpoof()
        end
    end
})


local slideBox = Tabs.Misc:AddRightGroupbox('slide boost')

slideBox:AddToggle('slide_boost', {
    Text = 'enable slide boost',
    Default = _G.Features.SlideBoost.Enabled,
    Callback = function(Value)
        _G.Features.SlideBoost.Enabled = Value
    end
})

slideBox:AddSlider('slide_speed', {
    Text = 'slide speed',
    Default = _G.Features.SlideBoost.Speed,
    Min = 100,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        _G.Features.SlideBoost.Speed = Value
    end
})


task.spawn(function()
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    
    while not LocalPlayer do
        task.wait()
        LocalPlayer = Players.LocalPlayer
    end
    
    
    local mech
    while true do
        local success, result = pcall(function()
            return require(LocalPlayer.PlayerScripts.Controllers.MechanicsController)
        end)
        
        if success then
            mech = result
            break
        end
        task.wait(1)
    end
    
    
    local connection
    connection = RunService.RenderStepped:Connect(function()
        if _G.Features.SlideBoost.Enabled and mech and mech.IsSliding then
            local success = pcall(function()
                mech._sliding_velocity.Velocity = mech._sliding_velocity.Velocity.Unit * _G.Features.SlideBoost.Speed
            end)
            
            
            if not success then
                local newSuccess, newMech = pcall(function()
                    return require(LocalPlayer.PlayerScripts.Controllers.MechanicsController)
                end)
                if newSuccess then
                    mech = newMech
                end
            end
        end
    end)
    
    
    game:GetService("Players").PlayerRemoving:Connect(function(player)
        if player == LocalPlayer then
            connection:Disconnect()
        end
    end)
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if _G.Features.DeviceSpoof.Enabled then
        task.wait(0.5)
        applyDeviceSpoof()
    end
end)

task.spawn(function()
    game:GetService("ReplicatedStorage"):WaitForChild("Remotes", 10)
    task.wait(2)
    if _G.Features.DeviceSpoof.Enabled then
        applyDeviceSpoof()
    end
end)

task.spawn(function()
    while true do
        task.wait(10)
        checkAndReapplyDeviceSpoof()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local gui_inset = GuiService:GetGuiInset()

_G.Config = _G.Config or {
    Box = {
        MasterEnabled = false,
        Enable = false,
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillColor = Color3.fromRGB(255, 255, 255),
        Filled = { Enable = false, Transparency = 0.5 },
        Healthbar = { 
            Enable = false,
            Thickness = 4
        },
        HealthLerpColors = {
            Color1 = Color3.fromRGB(0, 255, 0),
            Color2 = Color3.fromRGB(255, 255, 0),
            Color3 = Color3.fromRGB(255, 0, 0)
        }
    },
    TextESP = {
        Names = false,
        Distance = false,
        Tools = false,
        NameSize = 8,
        DistanceSize = 8,
        ToolsSize = 8,
        NameColor = Color3.fromRGB(255, 255, 255),
        DistanceColor = Color3.fromRGB(255, 255, 255),
        ToolColor = Color3.fromRGB(255, 255, 255)
    },
    Skeleton = {
        Enable = false,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 1
    },
    Tracers = {
        Enable = false,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 1,
        FromBottom = true
    },
    HeadDots = {
        Enable = false,
        Color = Color3.fromRGB(255, 0, 0),
        Size = 5
    },
    Fade = {
        Enable = false,
        MaxDistance = 1000,
        MinTransparency = 0.2
    }
}

_G.ESPObjects = _G.ESPObjects or {}

local ConfigBox = _G.Config.Box
local ESPObjects = _G.ESPObjects

local r15_bones = {
    {"UpperTorso", "Head"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

local r6_bones = {
    {"Torso", "Head"},
    {"Torso", "Left Arm"},
    {"Torso", "Right Arm"},
    {"Torso", "Left Leg"},
    {"Torso", "Right Leg"}
}

local function load_font(name, weight, style, asset)
    if not isfile(asset.id) then 
        writefile(asset.id, asset.font) 
    end
    
    if isfile(name .. '.font') then 
        delfile(name .. '.font') 
    end
    
    local data = {
        name = name,
        faces = {{
            name = 'Regular',
            weight = weight,
            style = style,
            assetId = getcustomasset(asset.id)
        }}
    }
    
    writefile(name .. '.font', HttpService:JSONEncode(data))
    return getcustomasset(name .. '.font')
end

local fonts = {}
local font_ok = pcall(function()
    fonts.main = Font.new(load_font('Minecraftia', 400, 'normal', {
        id = 'visitor1.ttf',
        font = game:HttpGet("https://github.com/nymus573l/esp-fonts/raw/main/visitor1.ttf")
    }))
end)

if not font_ok then
    fonts.main = Font.fromEnum(Enum.Font.Code)
end

local function lerp_color(a, b, t)
    return Color3.new(
        a.R + (b.R - a.R) * t,
        a.G + (b.G - a.G) * t,
        a.B + (b.B - a.B) * t
    )
end

local function get_health_color(pct)
    local hc = ConfigBox.HealthLerpColors or {
        Color1 = Color3.fromRGB(0, 255, 0),
        Color2 = Color3.fromRGB(255, 255, 0),
        Color3 = Color3.fromRGB(255, 0, 0)
    }
    if pct > 0.5 then
        return lerp_color(hc.Color2, hc.Color1, (pct - 0.5) * 2)
    else
        return lerp_color(hc.Color3, hc.Color2, pct * 2)
    end
end

local function isTeammate(player)
    return LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team
end

local function espknock(player)
    local char = player.Character
    if not char then return false end
    local bodyEffects = char:FindFirstChild("BodyEffects")
    if bodyEffects then
        local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
        return ko and ko.Value
    end
    return false
end

local function getDistance(player)
    local char = player.Character
    local myChar = LocalPlayer.Character
    if char and myChar then
        local root = char:FindFirstChild("HumanoidRootPart")
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        if root and myRoot then
            return (root.Position - myRoot.Position).Magnitude
        end
    end
    return math.huge
end

local function getPlayerWeapon(player)
    local viewModels = Workspace:FindFirstChild("ViewModels")
    if not viewModels then return "None" end
    
    local playerName = player.Name
    
    for _, child in ipairs(viewModels:GetChildren()) do
        local childName = child.Name
        local parts = {}
        for part in childName:gmatch("[^-]+") do
            table.insert(parts, part:match("^%s*(.-)%s*$"))
        end
        
        if #parts >= 2 and parts[1] == playerName then
            return parts[2]
        end
    end
    
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if firstPerson then
        for _, child in ipairs(firstPerson:GetChildren()) do
            local childName = child.Name
            local parts = {}
            for part in childName:gmatch("[^-]+") do
                table.insert(parts, part:match("^%s*(.-)%s*$"))
            end
            
            if #parts >= 2 and parts[1] == playerName then
                return parts[2]
            end
        end
    end
    
    return "None"
end

local function make_label(parent)
    local label = Instance.new("TextLabel")
    label.Parent = parent
    label.Size = UDim2.new(0, 200, 0, 20)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextStrokeTransparency = 0
    label.TextScaled = false
    label.TextSize = 6
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.FontFace = fonts.main
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Top
    return label
end

local function CreateBox(player)
    if ESPObjects[player] then return end
    local box = {}
    
    box.box = {}
    box.box.square = Drawing.new("Square")
    box.box.inline = Drawing.new("Square")
    box.box.outline = Drawing.new("Square")
    
    box.bars = {}
    box.bars.hp_bars = {}
    box.bars.hp_outline = Drawing.new("Square")
    box.bars.last_hp = 1
    
    for i = 1, 50 do
        box.bars.hp_bars[i] = Drawing.new("Line")
    end
    
    box.skeleton = {lines = {}, outlines = {}}
    for i = 1, 15 do
        local outline = Drawing.new("Line")
        outline.Color = Color3.new(0, 0, 0)
        outline.Thickness = 3
        outline.Visible = false
        box.skeleton.outlines[i] = outline
        
        local line = Drawing.new("Line")
        line.Color = Color3.new(1, 1, 1)
        line.Thickness = 1
        line.Visible = false
        box.skeleton.lines[i] = line
    end
    
    local studs_gui = Instance.new("ScreenGui", game.CoreGui)
    local name_gui = Instance.new("ScreenGui", game.CoreGui)
    local tool_gui = Instance.new("ScreenGui", game.CoreGui)
    
    box.text = {}
    box.text.studs = make_label(studs_gui)
    box.text.tool = make_label(tool_gui)
    box.text.name = make_label(name_gui)
    
    box.Tracer = Drawing.new("Line")
    box.Tracer.Visible = false
    box.Tracer.Color = _G.Config.Tracers.Color or Color3.fromRGB(255, 255, 255)
    box.Tracer.Thickness = _G.Config.Tracers.Thickness or 1
    
    box.HeadDot = Drawing.new("Circle")
    box.HeadDot.Visible = false
    box.HeadDot.Color = _G.Config.HeadDots.Color or Color3.fromRGB(255, 0, 0)
    box.HeadDot.Radius = _G.Config.HeadDots.Size or 5
    box.HeadDot.Filled = true
    
    ESPObjects[player] = box
end

local function RemoveBox(player)
    if ESPObjects[player] then
        local box = ESPObjects[player]
        
        if box.box then
            box.box.square:Remove()
            box.box.outline:Remove()
            box.box.inline:Remove()
        end
        
        if box.text then
            if box.text.studs then box.text.studs.Parent:Destroy() end
            if box.text.tool then box.text.tool.Parent:Destroy() end
            if box.text.name then box.text.name.Parent:Destroy() end
        end
        
        if box.bars then
            box.bars.hp_outline:Remove()
            for _, line in pairs(box.bars.hp_bars) do
                line:Remove()
            end
        end
        
        if box.skeleton then
            for _, line in pairs(box.skeleton.lines) do
                line:Remove()
            end
            for _, outline in pairs(box.skeleton.outlines) do
                outline:Remove()
            end
        end
        
        if box.Tracer then box.Tracer:Remove() end
        if box.HeadDot then box.HeadDot:Remove() end
        
        ESPObjects[player] = nil
    end
end

local function hide_esp(player)
    if not ESPObjects[player] then return end
    
    local box = ESPObjects[player]
    
    if box.box then
        box.box.square.Visible = false
        box.box.outline.Visible = false
        box.box.inline.Visible = false
    end
    
    if box.text then
        box.text.studs.Visible = false
        box.text.tool.Visible = false
        box.text.name.Visible = false
    end
    
    if box.bars then
        box.bars.hp_outline.Visible = false
        for _, line in pairs(box.bars.hp_bars) do
            line.Visible = false
        end
    end
    
    if box.skeleton then
        for _, line in pairs(box.skeleton.lines) do
            line.Visible = false
        end
        for _, outline in pairs(box.skeleton.outlines) do
            outline.Visible = false
        end
    end
    
    if box.Tracer then box.Tracer.Visible = false end
    if box.HeadDot then box.HeadDot.Visible = false end
end

local function draw_skeleton(player, box, char, hum, size, position)
    if not _G.Config.Skeleton.Enable then
        for _, line in pairs(box.skeleton.lines) do
            line.Visible = false
        end
        for _, outline in pairs(box.skeleton.outlines) do
            outline.Visible = false
        end
        return
    end
    
    local bones = (hum.RigType == Enum.HumanoidRigType.R15) and r15_bones or r6_bones
    
    for i = 1, 15 do
        local boneset = bones[i]
        local line = box.skeleton.lines[i]
        local outline = box.skeleton.outlines[i]
        
        if boneset then
            local part_a = char:FindFirstChild(boneset[1])
            local part_b = char:FindFirstChild(boneset[2])
            
            if part_a and part_b then
                local va, on_a = Camera:WorldToViewportPoint(part_a.Position)
                local vb, on_b = Camera:WorldToViewportPoint(part_b.Position)
                
                if on_a and on_b then
                    local start_pos = Vector2.new(va.X, va.Y)
                    local end_pos = Vector2.new(vb.X, vb.Y)
                    
                    outline.Visible = true
                    outline.From = start_pos
                    outline.To = end_pos
                    outline.Thickness = (_G.Config.Skeleton.Thickness or 1) + 2
                    outline.ZIndex = 1
                    
                    line.Visible = true
                    line.From = start_pos
                    line.To = end_pos
                    line.Color = _G.Config.Skeleton.Color or Color3.fromRGB(255, 255, 255)
                    line.Thickness = _G.Config.Skeleton.Thickness or 1
                    line.ZIndex = 2
                else
                    line.Visible = false
                    outline.Visible = false
                end
            else
                line.Visible = false
                outline.Visible = false
            end
        else
            line.Visible = false
            outline.Visible = false
        end
    end
end

local function draw_healthbar(player, box, hum, size, position)
    if not (ConfigBox.Healthbar and ConfigBox.Healthbar.Enable) then
        box.bars.hp_outline.Visible = false
        for _, line in pairs(box.bars.hp_bars) do
            line.Visible = false
        end
        return
    end
    
    local target = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
    local last = box.bars.last_hp or target
    local lerped = last + (target - last) * 0.05
    box.bars.last_hp = lerped
    
    local h = size.Y * lerped
    local hp_x = position.X - 5
    local hp_y_start = position.Y + (size.Y - h)
    
    box.bars.hp_outline.Visible = true
    box.bars.hp_outline.Position = Vector2.new(hp_x - 1, position.Y - 1)
    box.bars.hp_outline.Size = Vector2.new(3, size.Y + 2)
    box.bars.hp_outline.Color = Color3.new(0, 0, 0)
    box.bars.hp_outline.Filled = false
    
    
    local segments = math.max(math.min(math.floor(h / 2), 50), 10) 
    for i = 1, 50 do
        local line = box.bars.hp_bars[i]
        if i <= segments then
            local segment_height = h / segments
            local y_offset = (i - 1) * segment_height
            local pos_pct = 1 - ((y_offset + (size.Y - h)) / size.Y)
            line.Visible = true
            line.From = Vector2.new(hp_x, hp_y_start + y_offset)
            line.To = Vector2.new(hp_x + 1, hp_y_start + y_offset)
            line.Color = get_health_color(pos_pct)
            line.Thickness = math.max(segment_height, 1)
        else
            line.Visible = false
        end
    end
end

local function draw_box(player, box, size, position)
    if not (ConfigBox.MasterEnabled and ConfigBox.Enable) then
        box.box.square.Visible = false
        box.box.outline.Visible = false
        box.box.inline.Visible = false
        return
    end
    
    box.box.square.Visible = true
    box.box.square.Position = position
    box.box.square.Size = size
    box.box.square.Color = ConfigBox.OutlineColor or Color3.fromRGB(255, 255, 255)
    box.box.square.Thickness = 1
    box.box.square.Filled = false
    box.box.square.ZIndex = 2
    
    box.box.outline.Visible = true
    box.box.outline.Position = position - Vector2.new(1, 1)
    box.box.outline.Size = size + Vector2.new(2, 2)
    box.box.outline.Color = Color3.new(0, 0, 0)
    box.box.outline.Filled = false
    
    box.box.inline.Visible = true
    box.box.inline.Position = position + Vector2.new(1, 1)
    box.box.inline.Size = size - Vector2.new(2, 2)
    box.box.inline.Color = Color3.new(0, 0, 0)
    box.box.inline.Filled = false
end

local function draw_text(player, box, size, position, distance)
    local base_y = position.Y - gui_inset.Y
    
    if _G.Config.TextESP and _G.Config.TextESP.Names then
        box.text.name.Visible = true
        box.text.name.Position = UDim2.new(0, position.X + (size.X / 2) - 100, 0, base_y - 15)
        box.text.name.Text = player.Name
        box.text.name.TextSize = _G.Config.TextESP.NameSize or 13
        box.text.name.TextColor3 = _G.Config.TextESP.NameColor or Color3.fromRGB(255, 255, 255)
        box.text.name.TextXAlignment = Enum.TextXAlignment.Center
    else
        box.text.name.Visible = false
    end
    
    if _G.Config.TextESP and _G.Config.TextESP.Tools then
        box.text.tool.Visible = true
        box.text.tool.Position = UDim2.new(0, position.X + size.X + 5, 0, base_y)
        box.text.tool.Text = getPlayerWeapon(player)
        box.text.tool.TextSize = _G.Config.TextESP.ToolsSize or 11
        box.text.tool.TextColor3 = _G.Config.TextESP.ToolColor or Color3.fromRGB(255, 255, 255)
        box.text.tool.TextXAlignment = Enum.TextXAlignment.Left
    else
        box.text.tool.Visible = false
    end
    
    if _G.Config.TextESP and _G.Config.TextESP.Distance then
        box.text.studs.Visible = true
        box.text.studs.Position = UDim2.new(0, position.X + (size.X / 2) - 100, 0, base_y + size.Y + 2)
        box.text.studs.Text = string.format("%.0f studs", distance)
        box.text.studs.TextSize = _G.Config.TextESP.DistanceSize or 11
        box.text.studs.TextColor3 = _G.Config.TextESP.DistanceColor or Color3.fromRGB(255, 255, 255)
        box.text.studs.TextXAlignment = Enum.TextXAlignment.Center
    else
        box.text.studs.Visible = false
    end
end

local function draw_tracers(player, box, root)
    if not (_G.Config.Tracers and _G.Config.Tracers.Enable) then
        box.Tracer.Visible = false
        return
    end
    
    local pos, vis = Camera:WorldToViewportPoint(root.Position)
    if vis then
        box.Tracer.Visible = true
        box.Tracer.To = Vector2.new(pos.X, pos.Y)
        box.Tracer.From = (_G.Config.Tracers.FromBottom == nil or _G.Config.Tracers.FromBottom) 
            and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y) 
            or Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        box.Tracer.Color = _G.Config.Tracers.Color or Color3.fromRGB(255, 255, 255)
        box.Tracer.Thickness = _G.Config.Tracers.Thickness or 1
    else
        box.Tracer.Visible = false
    end
end

local function draw_headdot(player, box, head)
    if not (_G.Config.HeadDots and _G.Config.HeadDots.Enable) then
        box.HeadDot.Visible = false
        return
    end
    
    local pos, vis = Camera:WorldToViewportPoint(head.Position)
    if vis then
        box.HeadDot.Visible = true
        box.HeadDot.Position = Vector2.new(pos.X, pos.Y)
        box.HeadDot.Color = _G.Config.HeadDots.Color or Color3.fromRGB(255, 0, 0)
        box.HeadDot.Radius = _G.Config.HeadDots.Size or 5
    else
        box.HeadDot.Visible = false
    end
end

local function update_esp(player)
    if not player or not ESPObjects[player] then return end
    
    if player == LocalPlayer or isTeammate(player) then
        hide_esp(player)
        return
    end
    
    local char = player.Character
    if not char or espknock(player) then
        hide_esp(player)
        return
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildWhichIsA("Humanoid")
    local head = char:FindFirstChild("Head")
    
    if not root or not hum or not head then
        hide_esp(player)
        return
    end
    
    local pos, on_screen = Camera:WorldToViewportPoint(root.Position)
    if not on_screen then
        hide_esp(player)
        return
    end
    
    local distance = getDistance(player)
    local maxDist = _G.Config.Fade.MaxDistance or 1000
    
    if distance > maxDist then
        hide_esp(player)
        return
    end
    
    local hrp2d = Camera:WorldToViewportPoint(root.Position)
    local clamped_dist = math.min(distance, 535)
    local ref_pos = root.Position + (Camera.CFrame.Position - root.Position).Unit * (distance - clamped_dist)
    
    local char_top = Camera:WorldToViewportPoint(ref_pos + Vector3.new(0, 3, 0))
    local char_bottom = Camera:WorldToViewportPoint(ref_pos - Vector3.new(0, 1, 0))
    local char_size = (char_bottom.Y - char_top.Y) / 2
    local size = Vector2.new(math.floor(char_size * 1.5), math.floor(char_size * 3.2))
    
    local actual_top = Camera:WorldToViewportPoint(root.Position + Vector3.new(0, 3, 0))
    local position = Vector2.new(math.floor(hrp2d.X - char_size * 1.5 / 2), math.floor(actual_top.Y))
    
    local box = ESPObjects[player]
    
    draw_box(player, box, size, position)
    draw_skeleton(player, box, char, hum, size, position)
    draw_healthbar(player, box, hum, size, position)
    draw_text(player, box, size, position, distance)
    draw_tracers(player, box, root)
    draw_headdot(player, box, head)
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then 
        CreateBox(player) 
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then 
        CreateBox(player) 
    end
end)

Players.PlayerRemoving:Connect(RemoveBox)

RunService.RenderStepped:Connect(function()
    for player, _ in pairs(ESPObjects) do
        update_esp(player)
    end
end)


local v67 = Tabs.Visuals:AddLeftGroupbox("esp")

v67:AddToggle('box_enabled', {
    Text = 'enable',
    Default = ConfigBox.MasterEnabled or false,
    Callback = function(Value)
        ConfigBox.MasterEnabled = Value
    end
})

v67:AddToggle('box_enabled2', {
    Text = 'boxes',
    Default = ConfigBox.Enable or false,
    Callback = function(Value)
        ConfigBox.Enable = Value
    end
}):AddColorPicker('box_outline_color', {
    Title = 'outline color',
    Default = ConfigBox.OutlineColor or Color3.fromRGB(255, 255, 255),
    Transparency = false,
    Callback = function(Value)
        ConfigBox.OutlineColor = Value
    end
})

v67:AddToggle('box_filled', {
    Text = 'filled',
    Default = (ConfigBox.Filled and ConfigBox.Filled.Enable) or false,
    Callback = function(Value)
        if not ConfigBox.Filled then
            ConfigBox.Filled = { Enable = false, Transparency = 0.5 }
        end
        ConfigBox.Filled.Enable = Value
    end
}):AddColorPicker('box_fill_color', {
    Title = 'fill color',
    Default = ConfigBox.FillColor or Color3.fromRGB(255, 255, 255),
    Transparency = false,
    Callback = function(Value)
        ConfigBox.FillColor = Value
    end
})

v67:AddSlider('box_fill_transparency', {
    Text = 'fill transparency',
    Default = (ConfigBox.Filled and ConfigBox.Filled.Transparency) or 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(Value)
        if not ConfigBox.Filled then
            ConfigBox.Filled = { Enable = false, Transparency = 0.5 }
        end
        ConfigBox.Filled.Transparency = Value
    end
})

v67:AddToggle('healthbar', {
    Text = 'healthbar',
    Default = (ConfigBox.Healthbar and ConfigBox.Healthbar.Enable) or false,
    Callback = function(Value)
        if not ConfigBox.Healthbar then
            ConfigBox.Healthbar = { Enable = false, Thickness = 4 }
        end
        ConfigBox.Healthbar.Enable = Value
    end
}):AddColorPicker('ColorPicker121212', {
    Default = (ConfigBox.HealthLerpColors and ConfigBox.HealthLerpColors.Color1) or Color3.fromRGB(0, 255, 0),
    Title = 'high health',
    Transparency = 0,
    Callback = function(Value)
        if not ConfigBox.HealthLerpColors then
            ConfigBox.HealthLerpColors = {
                Color1 = Color3.fromRGB(0, 255, 0),
                Color2 = Color3.fromRGB(255, 255, 0),
                Color3 = Color3.fromRGB(255, 0, 0)
            }
        end
        ConfigBox.HealthLerpColors.Color1 = Value
    end
}):AddColorPicker('ColorPicker21', {
    Default = (ConfigBox.HealthLerpColors and ConfigBox.HealthLerpColors.Color2) or Color3.fromRGB(255, 255, 0),
    Title = 'mid health',
    Transparency = 0,
    Callback = function(Value)
        if not ConfigBox.HealthLerpColors then
            ConfigBox.HealthLerpColors = {
                Color1 = Color3.fromRGB(0, 255, 0),
                Color2 = Color3.fromRGB(255, 255, 0),
                Color3 = Color3.fromRGB(255, 0, 0)
            }
        end
        ConfigBox.HealthLerpColors.Color2 = Value
    end
}):AddColorPicker('ColorPicker45', {
    Default = (ConfigBox.HealthLerpColors and ConfigBox.HealthLerpColors.Color3) or Color3.fromRGB(255, 0, 0),
    Title = 'low health',
    Transparency = 0,
    Callback = function(Value)
        if not ConfigBox.HealthLerpColors then
            ConfigBox.HealthLerpColors = {
                Color1 = Color3.fromRGB(0, 255, 0),
                Color2 = Color3.fromRGB(255, 255, 0),
                Color3 = Color3.fromRGB(255, 0, 0)
            }
        end
        ConfigBox.HealthLerpColors.Color3 = Value
    end
})

v67:AddToggle('textesp', {
    Text = 'names',
    Default = _G.Config.TextESP.Names or false,
    Callback = function(Value)
        _G.Config.TextESP.Names = Value
    end
}):AddColorPicker('name_color', {
    Title = 'name color',
    Default = _G.Config.TextESP.NameColor or Color3.fromRGB(255, 255, 255),
    Transparency = false,
    Callback = function(Value)
        _G.Config.TextESP.NameColor = Value
    end
})

v67:AddToggle('textesp_distance', {
    Text = 'distance',
    Default = _G.Config.TextESP.Distance or false,
    Callback = function(Value)
        _G.Config.TextESP.Distance = Value
    end
}):AddColorPicker('distance_color', {
    Title = 'distance color',
    Default = _G.Config.TextESP.DistanceColor or Color3.fromRGB(255, 255, 255),
    Transparency = false,
    Callback = function(Value)
        _G.Config.TextESP.DistanceColor = Value
    end
})

v67:AddToggle('textesp_tools', {
    Text = 'tools',
    Default = _G.Config.TextESP.Tools or false,
    Callback = function(Value)
        _G.Config.TextESP.Tools = Value
    end
}):AddColorPicker('tool_color', {
    Title = 'tool color',
    Default = _G.Config.TextESP.ToolColor or Color3.fromRGB(255, 255, 255),
    Transparency = false,
    Callback = function(Value)
        _G.Config.TextESP.ToolColor = Value
    end
})

v67:AddSlider('textesp_namesize', {
    Text = 'name size',
    Default = _G.Config.TextESP.NameSize or 8,
    Min = 8,
    Max = 16,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.Config.TextESP.NameSize = Value
    end
})

v67:AddSlider('textesp_distancesize', {
    Text = 'distance size',
    Default = _G.Config.TextESP.DistanceSize or 8,
    Min = 8,
    Max = 14,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.Config.TextESP.DistanceSize = Value
    end
})

v67:AddSlider('textesp_toolssize', {
    Text = 'tools size',
    Default = _G.Config.TextESP.ToolsSize or 8,
    Min = 8,
    Max = 14,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.Config.TextESP.ToolsSize = Value
    end
})

v67:AddToggle('skeleton', {
    Text = 'skeleton',
    Default = _G.Config.Skeleton.Enable or false,
    Callback = function(Value)
        _G.Config.Skeleton.Enable = Value
    end
}):AddColorPicker('skeleton_color', {
    Title = 'skeleton color',
    Default = _G.Config.Skeleton.Color or Color3.fromRGB(255, 255, 255),
    Transparency = false,
    Callback = function(Value)
        _G.Config.Skeleton.Color = Value
    end
})

v67:AddSlider('skeleton_thickness', {
    Text = 'skeleton thickness',
    Default = _G.Config.Skeleton.Thickness or 1,
    Min = 0.5,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.Config.Skeleton.Thickness = Value
    end
})

v67:AddToggle('tracers', {
    Text = 'tracers',
    Default = _G.Config.Tracers.Enable or false,
    Callback = function(Value)
        _G.Config.Tracers.Enable = Value
    end
}):AddColorPicker('tracers_color', {
    Title = 'tracer color',
    Default = _G.Config.Tracers.Color or Color3.fromRGB(255, 255, 255),
    Transparency = false,
    Callback = function(Value)
        _G.Config.Tracers.Color = Value
    end
})

v67:AddSlider('tracers_thickness', {
    Text = 'tracer thickness',
    Default = _G.Config.Tracers.Thickness or 1,
    Min = 0.5,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.Config.Tracers.Thickness = Value
    end
})

v67:AddToggle('tracers_frombottom', {
    Text = 'tracers from bottom',
    Default = _G.Config.Tracers.FromBottom or true,
    Callback = function(Value)
        _G.Config.Tracers.FromBottom = Value
    end
})

v67:AddToggle('headdots', {
    Text = 'head dots',
    Default = _G.Config.HeadDots.Enable or false,
    Callback = function(Value)
        _G.Config.HeadDots.Enable = Value
    end
}):AddColorPicker('headdots_color', {
    Title = 'head dot color',
    Default = _G.Config.HeadDots.Color or Color3.fromRGB(255, 0, 0),
    Transparency = false,
    Callback = function(Value)
        _G.Config.HeadDots.Color = Value
    end
})

v67:AddSlider('headdots_size', {
    Text = 'head dot size',
    Default = _G.Config.HeadDots.Size or 5,
    Min = 2,
    Max = 10,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.Config.HeadDots.Size = Value
    end
})

v67:AddToggle('fade', {
    Text = 'distance fade',
    Default = _G.Config.Fade.Enable or false,
    Callback = function(Value)
        _G.Config.Fade.Enable = Value
    end
})

v67:AddSlider('fade_distance', {
    Text = 'max fade distance',
    Default = _G.Config.Fade.MaxDistance or 1000,
    Min = 100,
    Max = 5000,
    Rounding = 0,
    Compact = true,
    Callback = function(Value)
        _G.Config.Fade.MaxDistance = Value
    end
})

v67:AddSlider('fade_mintransparency', {
    Text = 'min transparency',
    Default = _G.Config.Fade.MinTransparency or 0.2,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(Value)
        _G.Config.Fade.MinTransparency = Value
    end
})

getgenv().crosshair = {
    enabled = false,
    refreshrate = 0,
    mode = "mouse",
    position = Vector2.new(0, 0),
    crosshair_mode = "static", 

    width = 1.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(0, 186, 255),

    spin = true,
    spin_speed = 150,
    spin_max = 340,
    spin_style = Enum.EasingStyle.Sine,

    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22,
    scale_min = 1,
    scale_max = 1
}

local Run = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Tween = game:GetService("TweenService")
local Cam = workspace.CurrentCamera
local LocalPlayer = game:GetService("Players").LocalPlayer

local draw_text1 = Drawing.new("Text")
draw_text1.Size = 13
draw_text1.Font = 2
draw_text1.Outline = true
draw_text1.Text = "instance"
draw_text1.Color = Color3.new(1,1,1)

local draw_text2 = Drawing.new("Text")
draw_text2.Size = 13
draw_text2.Font = 2
draw_text2.Outline = true
draw_text2.Text = ".elf"

local lines = {}
for i = 1,8 do
    lines[i] = Drawing.new("Line")
end

local last = 0
local angles = {0,90,180,270}

local function solve(a, r)
    local rad = math.rad(a)
    return Vector2.new(math.sin(rad)*r, math.cos(rad)*r)
end

local function getMuzzlePosition()
    local viewModels = workspace:FindFirstChild("ViewModels")
    if not viewModels then return nil end
    
    local firstPerson = viewModels:FindFirstChild("FirstPerson")
    if not firstPerson then return nil end
    
    local playerName = LocalPlayer.Name
    
    for _, model in pairs(firstPerson:GetChildren()) do
        if model:IsA("Model") and model.Name:find("^" .. playerName) then
            local itemVisual = model:FindFirstChild("ItemVisual")
            if itemVisual then
                local body = itemVisual:FindFirstChild("Body")
                if body then
                    local bodyPrimary = body:FindFirstChild("BodyPrimary")
                    if bodyPrimary then
                        local muzzle = bodyPrimary:FindFirstChild("_muzzle")
                        if muzzle and muzzle:IsA("Attachment") then
                            return muzzle.WorldPosition
                        end
                    end
                end
            end
        end
    end
    
    return nil
end

Run.PostSimulation:Connect(function()
    local t = os.clock()
    if t - last < getgenv().crosshair.refreshrate then return end
    last = t

    local cfg = getgenv().crosshair
    
    local pos
    if cfg.crosshair_mode == "follow muzzle" then
        local muzzlePos = getMuzzlePosition()
        if muzzlePos then
            local screenPos, onScreen = Cam:WorldToViewportPoint(muzzlePos)
            if onScreen then
                pos = Vector2.new(screenPos.X, screenPos.Y)
            else
                
                pos = cfg.mode == "center" and Cam.ViewportSize/2 or
                      cfg.mode == "mouse" and UIS:GetMouseLocation() or
                      cfg.position
            end
        else
            
            pos = cfg.mode == "center" and Cam.ViewportSize/2 or
                  cfg.mode == "mouse" and UIS:GetMouseLocation() or
                  cfg.position
        end
    else
        pos = cfg.mode == "center" and Cam.ViewportSize/2 or
              cfg.mode == "mouse" and UIS:GetMouseLocation() or
              cfg.position
    end

    local enabled = cfg.enabled
    draw_text1.Visible = enabled
    draw_text2.Visible = enabled

    if not enabled then
        for i=1,8 do lines[i].Visible = false end
        return
    end

    local scale = cfg.scale_min + (math.sin(t * cfg.resize_speed) * (cfg.scale_max - cfg.scale_min))
    local base_y = cfg.radius + (cfg.resize and cfg.resize_max or cfg.length) * scale + 15
    local textpos = pos + Vector2.new(-(draw_text1.TextBounds.X + draw_text2.TextBounds.X)/2, base_y)
    draw_text1.Position = textpos
    draw_text2.Position = textpos + Vector2.new(draw_text1.TextBounds.X)
    draw_text2.Color = cfg.color

    local spin_angle = 0
    if cfg.spin then
        local raw = -(t * cfg.spin_speed) % cfg.spin_max
        spin_angle = Tween:GetValue(raw/360, cfg.spin_style, Enum.EasingDirection.InOut) * 360
    end

    local length = cfg.length
    if cfg.resize then
        local s = (t * cfg.resize_speed) % 180
        length = cfg.resize_min + math.sin(math.rad(s)) * cfg.resize_max
    end

    for i = 1,4 do
        local basea = angles[i] + spin_angle
        local p1 = pos + solve(basea, cfg.radius * scale)
        local p2 = pos + solve(basea, (cfg.radius + length) * scale)

        local inl = lines[i+4]
        inl.Visible = true
        inl.Color = cfg.color
        inl.From = p1
        inl.To = p2
        inl.Thickness = cfg.width

        local out = lines[i]
        out.Visible = true
        out.Color = Color3.new(0,0,0)
        out.From = pos + solve(basea, cfg.radius * scale - 1)
        out.To = pos + solve(basea, (cfg.radius + length) * scale + 1)
        out.Thickness = cfg.width + 1.5
    end
end)

v67:AddToggle('crosshaireeee',{
    Text='crosshair',
    Default=false,
    Callback=function(Value)
        getgenv().crosshair.enabled = Value
    end
}):AddColorPicker('ColorPickerhgfhgfh45445fgfgfg4', {
    Default = getgenv().crosshair.color,
    Title = 'accent color',
    Transparency = 0,
    Callback = function(Value)
        getgenv().crosshair.color = Value
    end
})

v67:AddDropdown('crosshairmode', {
    Text = 'crosshair mode',
    Default = 1,
    Values = {'static', 'follow muzzle'},
    Callback = function(Value)
        getgenv().crosshair.crosshair_mode = Value
    end
})

v67:AddSlider('ooetg',{
    Text='spin speed',
    Default= getgenv().crosshair.spin_speed,
    Min=0,
    Max=340,
    Rounding=2,
    Compact=true,
    Callback=function(Value)
        getgenv().crosshair.spin_speed = Value
    end
})



local lightningBox = Tabs.Visuals:AddRightGroupbox('lighting')

_G.LightingSettings = _G.LightingSettings or {
    Enabled = false,

    Ambient = { Enabled = false, Color = Color3.fromRGB(255, 255, 255) },
    OutdoorAmbient = { Enabled = false, Color = Color3.fromRGB(165, 165, 165) },
    Brightness = { Enabled = false, Value = 3 },
    GlobalShadows = { Enabled = true },
    ShadowSoftness = { Enabled = false, Value = 0.2 },

    ColorShiftTop = { Enabled = false, Color = Color3.fromRGB(255, 100, 100) },
    ColorShiftBottom = { Enabled = false, Color = Color3.fromRGB(0, 50, 150) },

    ClockTime = { Enabled = false, Value = 12 },
    GeographicLatitude = { Enabled = false, Value = 41.8 },

    Fog = { Enabled = false, Color = Color3.fromRGB(100, 100, 150), Start = 0, End = 100 },

    EnvironmentDiffuseScale = { Enabled = false, Value = 1 },
    EnvironmentSpecularScale = { Enabled = false, Value = 1 },
}

local Lighting = game:GetService("Lighting")
local originalValues = {}
local updateConnection = nil


local function storeOriginalValues()
    originalValues.Ambient = Lighting.Ambient
    originalValues.OutdoorAmbient = Lighting.OutdoorAmbient
    originalValues.Brightness = Lighting.Brightness
    originalValues.GlobalShadows = Lighting.GlobalShadows
    originalValues.ShadowSoftness = Lighting.ShadowSoftness
    originalValues.ColorShift_Top = Lighting.ColorShift_Top
    originalValues.ColorShift_Bottom = Lighting.ColorShift_Bottom
    originalValues.ClockTime = Lighting.ClockTime
    originalValues.GeographicLatitude = Lighting.GeographicLatitude
    originalValues.FogColor = Lighting.FogColor
    originalValues.FogStart = Lighting.FogStart
    originalValues.FogEnd = Lighting.FogEnd
    originalValues.EnvironmentDiffuseScale = Lighting.EnvironmentDiffuseScale
    originalValues.EnvironmentSpecularScale = Lighting.EnvironmentSpecularScale
end

storeOriginalValues()

local function startLightingUpdater()
    if updateConnection then
        updateConnection:Disconnect()
        updateConnection = nil
    end
    
    updateConnection = RunService.RenderStepped:Connect(function()
        if not _G.LightingSettings.Enabled then return end
        
        if _G.LightingSettings.Ambient.Enabled then
            Lighting.Ambient = _G.LightingSettings.Ambient.Color
        else
            Lighting.Ambient = originalValues.Ambient
        end
        
        if _G.LightingSettings.OutdoorAmbient.Enabled then
            Lighting.OutdoorAmbient = _G.LightingSettings.OutdoorAmbient.Color
        else
            Lighting.OutdoorAmbient = originalValues.OutdoorAmbient
        end
        
        if _G.LightingSettings.Brightness.Enabled then
            Lighting.Brightness = _G.LightingSettings.Brightness.Value
        else
            Lighting.Brightness = originalValues.Brightness
        end
        
        if _G.LightingSettings.GlobalShadows.Enabled ~= nil then
            Lighting.GlobalShadows = _G.LightingSettings.GlobalShadows.Enabled
        else
            Lighting.GlobalShadows = originalValues.GlobalShadows
        end
        
        if _G.LightingSettings.ShadowSoftness.Enabled then
            Lighting.ShadowSoftness = _G.LightingSettings.ShadowSoftness.Value
        else
            Lighting.ShadowSoftness = originalValues.ShadowSoftness
        end
        
        if _G.LightingSettings.ColorShiftTop.Enabled then
            Lighting.ColorShift_Top = _G.LightingSettings.ColorShiftTop.Color
        else
            Lighting.ColorShift_Top = originalValues.ColorShift_Top
        end
        
        if _G.LightingSettings.ColorShiftBottom.Enabled then
            Lighting.ColorShift_Bottom = _G.LightingSettings.ColorShiftBottom.Color
        else
            Lighting.ColorShift_Bottom = originalValues.ColorShift_Bottom
        end
        
        if _G.LightingSettings.ClockTime.Enabled then
            Lighting.ClockTime = _G.LightingSettings.ClockTime.Value
        else
            Lighting.ClockTime = originalValues.ClockTime
        end
        
        if _G.LightingSettings.GeographicLatitude.Enabled then
            Lighting.GeographicLatitude = _G.LightingSettings.GeographicLatitude.Value
        else
            Lighting.GeographicLatitude = originalValues.GeographicLatitude
        end
        
        if _G.LightingSettings.Fog.Enabled then
            Lighting.FogColor = _G.LightingSettings.Fog.Color
            Lighting.FogStart = _G.LightingSettings.Fog.Start
            Lighting.FogEnd = _G.LightingSettings.Fog.End
        else
            Lighting.FogColor = originalValues.FogColor
            Lighting.FogStart = originalValues.FogStart
            Lighting.FogEnd = originalValues.FogEnd
        end
        
        if _G.LightingSettings.EnvironmentDiffuseScale.Enabled then
            Lighting.EnvironmentDiffuseScale = _G.LightingSettings.EnvironmentDiffuseScale.Value
        else
            Lighting.EnvironmentDiffuseScale = originalValues.EnvironmentDiffuseScale
        end
        
        if _G.LightingSettings.EnvironmentSpecularScale.Enabled then
            Lighting.EnvironmentSpecularScale = _G.LightingSettings.EnvironmentSpecularScale.Value
        else
            Lighting.EnvironmentSpecularScale = originalValues.EnvironmentSpecularScale
        end
    end)
end

local function stopLightingUpdater()
    if updateConnection then
        updateConnection:Disconnect()
        updateConnection = nil
    end

    Lighting.Ambient = originalValues.Ambient
    Lighting.OutdoorAmbient = originalValues.OutdoorAmbient
    Lighting.Brightness = originalValues.Brightness
    Lighting.GlobalShadows = originalValues.GlobalShadows
    Lighting.ShadowSoftness = originalValues.ShadowSoftness
    Lighting.ColorShift_Top = originalValues.ColorShift_Top
    Lighting.ColorShift_Bottom = originalValues.ColorShift_Bottom
    Lighting.ClockTime = originalValues.ClockTime
    Lighting.GeographicLatitude = originalValues.GeographicLatitude
    Lighting.FogColor = originalValues.FogColor
    Lighting.FogStart = originalValues.FogStart
    Lighting.FogEnd = originalValues.FogEnd
    Lighting.EnvironmentDiffuseScale = originalValues.EnvironmentDiffuseScale
    Lighting.EnvironmentSpecularScale = originalValues.EnvironmentSpecularScale
end

lightningBox:AddToggle('lighting_master', {
    Text = 'enable',
    Default = _G.LightingSettings.Enabled,
    Callback = function(v)
        _G.LightingSettings.Enabled = v
        if v then
            startLightingUpdater()
        else
            stopLightingUpdater()
        end
    end
})

local ambientToggle = lightningBox:AddToggle('lighting_ambient', {
    Text = 'custom ambient',
    Default = _G.LightingSettings.Ambient.Enabled,
    Callback = function(v)
        _G.LightingSettings.Ambient.Enabled = v
    end
})

ambientToggle:AddColorPicker('lighting_ambient_color', {
    Default = _G.LightingSettings.Ambient.Color,
    Title = 'ambient color',
    Callback = function(c)
        _G.LightingSettings.Ambient.Color = c
    end
})

local outdoorToggle = lightningBox:AddToggle('lighting_outdoorambient', {
    Text = 'custom outdoor ambient',
    Default = _G.LightingSettings.OutdoorAmbient.Enabled,
    Callback = function(v)
        _G.LightingSettings.OutdoorAmbient.Enabled = v
    end
})

outdoorToggle:AddColorPicker('lighting_outdoorambient_color', {
    Default = _G.LightingSettings.OutdoorAmbient.Color,
    Title = 'outdoor ambient color',
    Callback = function(c)
        _G.LightingSettings.OutdoorAmbient.Color = c
    end
})

lightningBox:AddToggle('lighting_brightness', {
    Text = 'custom brightness',
    Default = _G.LightingSettings.Brightness.Enabled,
    Callback = function(v)
        _G.LightingSettings.Brightness.Enabled = v
    end
})

lightningBox:AddSlider('lighting_brightness_value', {
    Text = 'brightness',
    Min = 0,
    Max = 10,
    Default = 3,
    Rounding = 2,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.Brightness.Value = v
    end
})

lightningBox:AddToggle('lighting_globalshadows', {
    Text = 'global shadows',
    Default = _G.LightingSettings.GlobalShadows.Enabled,
    Callback = function(v)
        _G.LightingSettings.GlobalShadows.Enabled = v
    end
})

lightningBox:AddToggle('lighting_shadowsoftness', {
    Text = 'custom shadow softness',
    Default = _G.LightingSettings.ShadowSoftness.Enabled,
    Callback = function(v)
        _G.LightingSettings.ShadowSoftness.Enabled = v
    end
})

lightningBox:AddSlider('lighting_shadowsoftness_value', {
    Text = 'shadow softness',
    Min = 0,
    Max = 1,
    Default = 0.2,
    Rounding = 2,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.ShadowSoftness.Value = v
    end
})

local topShiftToggle = lightningBox:AddToggle('lighting_colorshifttop', {
    Text = 'color shift top',
    Default = _G.LightingSettings.ColorShiftTop.Enabled,
    Callback = function(v)
        _G.LightingSettings.ColorShiftTop.Enabled = v
    end
})

topShiftToggle:AddColorPicker('lighting_colorshifttop_color', {
    Default = _G.LightingSettings.ColorShiftTop.Color,
    Title = 'top color',
    Callback = function(c)
        _G.LightingSettings.ColorShiftTop.Color = c
    end
})

local bottomShiftToggle = lightningBox:AddToggle('lighting_colorshiftbottom', {
    Text = 'color shift bottom',
    Default = _G.LightingSettings.ColorShiftBottom.Enabled,
    Callback = function(v)
        _G.LightingSettings.ColorShiftBottom.Enabled = v
    end
})

bottomShiftToggle:AddColorPicker('lighting_colorshiftbottom_color', {
    Default = _G.LightingSettings.ColorShiftBottom.Color,
    Title = 'bottom color',
    Callback = function(c)
        _G.LightingSettings.ColorShiftBottom.Color = c
    end
})

lightningBox:AddToggle('lighting_clocktime', {
    Text = 'custom time',
    Default = _G.LightingSettings.ClockTime.Enabled,
    Callback = function(v)
        _G.LightingSettings.ClockTime.Enabled = v
    end
})

lightningBox:AddSlider('lighting_clocktime_value', {
    Text = 'hour',
    Min = 0,
    Max = 24,
    Default = 12,
    Rounding = 1,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.ClockTime.Value = v
    end
})

lightningBox:AddToggle('lighting_latitude', {
    Text = 'custom latitude',
    Default = _G.LightingSettings.GeographicLatitude.Enabled,
    Callback = function(v)
        _G.LightingSettings.GeographicLatitude.Enabled = v
    end
})

lightningBox:AddSlider('lighting_latitude_value', {
    Text = 'geographic latitude',
    Min = -90,
    Max = 90,
    Default = 41.8,
    Rounding = 1,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.GeographicLatitude.Value = v
    end
})

local fogToggle = lightningBox:AddToggle('lighting_fog', {
    Text = 'custom fog',
    Default = _G.LightingSettings.Fog.Enabled,
    Callback = function(v)
        _G.LightingSettings.Fog.Enabled = v
    end
})

fogToggle:AddColorPicker('lighting_fog_color', {
    Default = _G.LightingSettings.Fog.Color,
    Title = 'fog color',
    Callback = function(c)
        _G.LightingSettings.Fog.Color = c
    end
})

lightningBox:AddSlider('lighting_fogstart', {
    Text = 'fog start',
    Min = 0,
    Max = 1000,
    Default = 0,
    Rounding = 0,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.Fog.Start = v
    end
})

lightningBox:AddSlider('lighting_fogend', {
    Text = 'fog end',
    Min = 0,
    Max = 100000,
    Default = 100,
    Rounding = 0,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.Fog.End = v
    end
})

lightningBox:AddToggle('lighting_diffuse', {
    Text = 'custom diffuse scale',
    Default = _G.LightingSettings.EnvironmentDiffuseScale.Enabled,
    Callback = function(v)
        _G.LightingSettings.EnvironmentDiffuseScale.Enabled = v
    end
})

lightningBox:AddSlider('lighting_diffuse_value', {
    Text = 'diffuse scale',
    Min = 0,
    Max = 2,
    Default = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.EnvironmentDiffuseScale.Value = v
    end
})

lightningBox:AddToggle('lighting_specular', {
    Text = 'custom specular scale',
    Default = _G.LightingSettings.EnvironmentSpecularScale.Enabled,
    Callback = function(v)
        _G.LightingSettings.EnvironmentSpecularScale.Enabled = v
    end
})

lightningBox:AddSlider('lighting_specular_value', {
    Text = 'specular scale',
    Min = 0,
    Max = 2,
    Default = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(v)
        _G.LightingSettings.EnvironmentSpecularScale.Value = v
    end
})

if _G.LightingSettings.Enabled then
    startLightingUpdater()
end

game:GetService("ScriptContext").DescendantRemoving:Connect(function(descendant)
    if descendant == script then
        stopLightingUpdater()
    end
end)


local skyboxBox = Tabs.World:AddLeftGroupbox('skybox')

_G.SkyboxSettings = _G.SkyboxSettings or {
    Enabled = false,
    CurrentSkybox = "Default",
    CustomTextures = {
        SkyboxBk = "rbxassetid://91458024",
        SkyboxDn = "rbxassetid://91457980",
        SkyboxFt = "rbxassetid://91458024",
        SkyboxLf = "rbxassetid://91458024",
        SkyboxRt = "rbxassetid://91458024",
        SkyboxUp = "rbxassetid://91458002",
    }
}

local Skyboxes = {
    Default = {
        SkyboxBk = "rbxassetid://91458024",
        SkyboxDn = "rbxassetid://91457980",
        SkyboxFt = "rbxassetid://91458024",
        SkyboxLf = "rbxassetid://91458024",
        SkyboxRt = "rbxassetid://91458024",
        SkyboxUp = "rbxassetid://91458002",
    },
    Neptune = {
        SkyboxBk = "rbxassetid://218955819",
        SkyboxDn = "rbxassetid://218953419",
        SkyboxFt = "rbxassetid://218954524",
        SkyboxLf = "rbxassetid://218958493",
        SkyboxRt = "rbxassetid://218957134",
        SkyboxUp = "rbxassetid://218950090",
    },
    ["Among Us"] = {
        SkyboxBk = "rbxassetid://5752463190",
        SkyboxDn = "rbxassetid://5752463190",
        SkyboxFt = "rbxassetid://5752463190",
        SkyboxLf = "rbxassetid://5752463190",
        SkyboxRt = "rbxassetid://5752463190",
        SkyboxUp = "rbxassetid://5752463190",
    },
    Nebula = {
        SkyboxBk = "rbxassetid://159454299",
        SkyboxDn = "rbxassetid://159454296",
        SkyboxFt = "rbxassetid://159454293",
        SkyboxLf = "rbxassetid://159454286",
        SkyboxRt = "rbxassetid://159454300",
        SkyboxUp = "rbxassetid://159454288",
    },
    Vaporwave = {
        SkyboxBk = "rbxassetid://1417494030",
        SkyboxDn = "rbxassetid://1417494146",
        SkyboxFt = "rbxassetid://1417494253",
        SkyboxLf = "rbxassetid://1417494402",
        SkyboxRt = "rbxassetid://1417494499",
        SkyboxUp = "rbxassetid://1417494643",
    },
    Clouds = {
        SkyboxBk = "rbxassetid://570557514",
        SkyboxDn = "rbxassetid://570557775",
        SkyboxFt = "rbxassetid://570557559",
        SkyboxLf = "rbxassetid://570557620",
        SkyboxRt = "rbxassetid://570557672",
        SkyboxUp = "rbxassetid://570557727",
    },
    Twilight = {
        SkyboxBk = "rbxassetid://264908339",
        SkyboxDn = "rbxassetid://264907909",
        SkyboxFt = "rbxassetid://264909420",
        SkyboxLf = "rbxassetid://264909758",
        SkyboxRt = "rbxassetid://264908886",
        SkyboxUp = "rbxassetid://264907379",
    },
    DaBaby = {
        SkyboxBk = "rbxassetid://7245418472",
        SkyboxDn = "rbxassetid://7245418472",
        SkyboxFt = "rbxassetid://7245418472",
        SkyboxLf = "rbxassetid://7245418472",
        SkyboxRt = "rbxassetid://7245418472",
        SkyboxUp = "rbxassetid://7245418472",
    },
    Minecraft = {
        SkyboxBk = "rbxassetid://1876545003",
        SkyboxDn = "rbxassetid://1876544331",
        SkyboxFt = "rbxassetid://1876542941",
        SkyboxLf = "rbxassetid://1876543392",
        SkyboxRt = "rbxassetid://1876543764",
        SkyboxUp = "rbxassetid://1876544642",
    },
    Chill = {
        SkyboxBk = "rbxassetid://5084575798",
        SkyboxDn = "rbxassetid://5084575916",
        SkyboxFt = "rbxassetid://5103949679",
        SkyboxLf = "rbxassetid://5103948542",
        SkyboxRt = "rbxassetid://5103948784",
        SkyboxUp = "rbxassetid://5084576400",
    },
    Redshift = {
        SkyboxBk = "rbxassetid://401664839",
        SkyboxDn = "rbxassetid://401664862",
        SkyboxFt = "rbxassetid://401664960",
        SkyboxLf = "rbxassetid://401664881",
        SkyboxRt = "rbxassetid://401664901",
        SkyboxUp = "rbxassetid://401664936",
    },
    ["Blue Stars"] = {
        SkyboxBk = "rbxassetid://149397684",
        SkyboxDn = "rbxassetid://149397686",
        SkyboxFt = "rbxassetid://149397688",
        SkyboxLf = "rbxassetid://149397692",
        SkyboxRt = "rbxassetid://149397697",
        SkyboxUp = "rbxassetid://149397702",
    },
    ["Blue Aurora"] = {
        SkyboxBk = "rbxassetid://12063984",
        SkyboxDn = "rbxassetid://12064107",
        SkyboxFt = "rbxassetid://12064152",
        SkyboxLf = "rbxassetid://12064121",
        SkyboxRt = "rbxassetid://12064115",
        SkyboxUp = "rbxassetid://12064131",
    },
}

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local skyboxConnection = nil
local customSky = nil
local originalSky = nil

local function storeOriginalSky()
    originalSky = Lighting:FindFirstChildOfClass("Sky")
end

storeOriginalSky()

local function getOrCreateSkybox()
    if not customSky then
        customSky = Instance.new("Sky")
        customSky.Name = "CustomSkybox"
        customSky.Parent = Lighting
    end
    return customSky
end

local function removeCustomSky()
    if customSky then
        customSky:Destroy()
        customSky = nil
    end
end

local function startSkyboxUpdater()
    if skyboxConnection then
        skyboxConnection:Disconnect()
        skyboxConnection = nil
    end
    
    skyboxConnection = RunService.RenderStepped:Connect(function()
        if not _G.SkyboxSettings.Enabled then
            removeCustomSky()
            return
        end
        
        local sky = getOrCreateSkybox()
        
        local textures
        if Skyboxes[_G.SkyboxSettings.CurrentSkybox] then
            textures = Skyboxes[_G.SkyboxSettings.CurrentSkybox]
        else
            textures = _G.SkyboxSettings.CustomTextures
        end
        
        sky.SkyboxBk = textures.SkyboxBk
        sky.SkyboxDn = textures.SkyboxDn
        sky.SkyboxFt = textures.SkyboxFt
        sky.SkyboxLf = textures.SkyboxLf
        sky.SkyboxRt = textures.SkyboxRt
        sky.SkyboxUp = textures.SkyboxUp
        
        for _, obj in pairs(Lighting:GetChildren()) do
            if obj:IsA("Sky") and obj ~= sky then
                obj:Destroy()
            end
        end
        
        if sky.Parent ~= Lighting then
            sky.Parent = Lighting
        end
    end)
end

local function stopSkyboxUpdater()
    if skyboxConnection then
        skyboxConnection:Disconnect()
        skyboxConnection = nil
    end
    
    removeCustomSky()
    
    if originalSky and not originalSky.Parent then
        originalSky.Parent = Lighting
    end
end

skyboxBox:AddToggle('skybox_master', {
    Text = 'enable',
    Default = _G.SkyboxSettings.Enabled,
    Callback = function(v)
        _G.SkyboxSettings.Enabled = v
        if v then
            startSkyboxUpdater()
        else
            stopSkyboxUpdater()
        end
    end
})

local skyboxList = {}
for name, _ in pairs(Skyboxes) do
    table.insert(skyboxList, name)
end
table.sort(skyboxList)

skyboxBox:AddDropdown('skybox_selection', {
    Text = 'skybox',
    Default = _G.SkyboxSettings.CurrentSkybox,
    Values = skyboxList,
    Callback = function(v)
        _G.SkyboxSettings.CurrentSkybox = v
    end
})

if _G.SkyboxSettings.Enabled then
    startSkyboxUpdater()
end

local aspectRatioBox = Tabs.World:AddLeftGroupbox('aspect ratio')

_G.AspectRatioSettings = _G.AspectRatioSettings or {
    Enabled = false,
    X = 13,
    Y = 10
}

local Camera = workspace.CurrentCamera
local aspectRatioConnection = nil

local function calculateRatio()
    return _G.AspectRatioSettings.X / _G.AspectRatioSettings.Y
end
local function updateAspectRatio()
    if not _G.AspectRatioSettings.Enabled or not Camera then
        return
    end
    local ratio = calculateRatio()
    Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, ratio, 0, 0, 0, 1)
end

local function startAspectRatioUpdater()
    if aspectRatioConnection then
        aspectRatioConnection:Disconnect()
        aspectRatioConnection = nil
    end
    
    aspectRatioConnection = game:GetService("RunService").RenderStepped:Connect(function()
        updateAspectRatio()
    end)
end

local function stopAspectRatioUpdater()
    if aspectRatioConnection then
        aspectRatioConnection:Disconnect()
        aspectRatioConnection = nil
    end
    
end

aspectRatioBox:AddToggle('aspect_ratio_master', {
    Text = 'enable',
    Default = _G.AspectRatioSettings.Enabled,
    Callback = function(v)
        _G.AspectRatioSettings.Enabled = v
        if v then
            startAspectRatioUpdater()
        else
            stopAspectRatioUpdater()
        end
    end
})

aspectRatioBox:AddSlider('aspect_ratio_x', {
    Text = 'x ratio',
    Default = _G.AspectRatioSettings.X,
    Min = 1,
    Max = 13,
    Rounding = 0,
    Callback = function(v)
        _G.AspectRatioSettings.X = v
    end
})

aspectRatioBox:AddSlider('aspect_ratio_y', {
    Text = 'y ratio',
    Default = _G.AspectRatioSettings.Y,
    Min = 10,
    Max = 32,
    Rounding = 0,
    Callback = function(v)
        _G.AspectRatioSettings.Y = v
    end
})

if _G.AspectRatioSettings.Enabled then
    startAspectRatioUpdater()
end

game:GetService("ScriptContext").DescendantRemoving:Connect(function(descendant)
    if descendant == script then
        stopSkyboxUpdater()
    end
end)

    local FrameTimer = tick()
    local FrameCounter = 0;
    local FPS = 60;

    local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
        FrameCounter += 1;

        if (tick() - FrameTimer) >= 1 then
            FPS = FrameCounter;
            FrameTimer = tick();
            FrameCounter = 0;
        end;

        Library:SetWatermark(('Instance.elf | %s fps'):format(
            math.floor(FPS)
        ));
    end);

    Library:OnUnload(function()
        if WatermarkConnection then
            WatermarkConnection:Disconnect()
        end
        Library.Unloaded = true
    end)

Library.KeybindFrame.Visible = true
MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('menu settings')

MenuGroup:AddLabel('menu bind'):AddKeyPicker('MenuKeybind', { 
    Default = 'RightControl', 
    NoUI = true, 
    Text = 'menu keybind' 
})

Library.ToggleKeybind = Options.MenuKeybind

MenuGroup:AddToggle('KeybindVisible', {
    Text = 'keybind list',
    Default = true,
    Callback = function(Value) 
        Library.KeybindFrame.Visible = Value 
    end
})

MenuGroup:AddSlider('tgbtgbbktbkmb', {
    Text = 'cap fps at',
    Default = 9999,
    Min = 10,
    Max = 9999,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        setfpscap(Value)
    end
})

MenuGroup:AddButton('Unload Menu', function()
    Library:Unload()
end)

local ServerGroup = Tabs['UI Settings']:AddRightGroupbox('server')

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function getServerList(cursor)
    local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
    if cursor then
        url = url .. "&cursor=" .. cursor
    end

    local success, response = pcall(function()
        return game:HttpGet(url)
    end)

    if not success then return nil end

    local success2, data = pcall(function()
        return HttpService:JSONDecode(response)
    end)

    if not success2 or not data or not data.data then
        return nil
    end

    return data
end

local function getAllServers()
    local servers = {}
    local cursor = nil

    repeat
        local data = getServerList(cursor)
        if not data then break end

        for _, server in ipairs(data.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                table.insert(servers, server)
            end
        end

        cursor = data.nextPageCursor
    until not cursor

    return servers
end

ServerGroup:AddButton('Rejoin Server', function()
    if game.JobId ~= "" then
        Library:Notify("Rejoining server...", 3)
        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
    else
        Library:Notify("No valid JobId.", 3)
    end
end)

ServerGroup:AddButton('Server Hop (Random)', function()
    local servers = getAllServers()
    if #servers == 0 then
        Library:Notify("No servers found.", 3)
        return
    end

    local s = servers[math.random(#servers)]
    Library:Notify("Hopping to server (" .. s.playing .. "/" .. s.maxPlayers .. " players)", 5)
    TeleportService:TeleportToPlaceInstance(game.PlaceId, s.id, LocalPlayer)
end)

ServerGroup:AddButton('Join Lowest Players Server', function()
    local servers = getAllServers()
    if #servers == 0 then
        Library:Notify("No servers found.", 3)
        return
    end

    table.sort(servers, function(a, b)
        return a.playing < b.playing
    end)

    local s = servers[1]
    Library:Notify("Joining lowest server (" .. s.playing .. "/" .. s.maxPlayers .. " players)", 5)
    TeleportService:TeleportToPlaceInstance(game.PlaceId, s.id, LocalPlayer)
end)

ServerGroup:AddButton('Join Biggest Server', function()
    local servers = getAllServers()
    if #servers == 0 then
        Library:Notify("No servers found.", 3)
        return
    end

    table.sort(servers, function(a, b)
        return a.playing > b.playing
    end)

    local s = servers[1]
    Library:Notify("Joining biggest server (" .. s.playing .. "/" .. s.maxPlayers .. " players)", 5)
    TeleportService:TeleportToPlaceInstance(game.PlaceId, s.id, LocalPlayer)
end)

ThemeManager:SetLibrary(Library)
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:SetLibrary(Library)
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('instance')
SaveManager:SetFolder('instance/rivals')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
